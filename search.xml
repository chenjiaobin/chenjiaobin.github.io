<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue-router前端路由的两种实现</title>
      <link href="/2019/02/24/vue-router%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/24/vue-router%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。<a id="more"></a>大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>在初始化对应的history之前，会对mode做一些校验：若浏览器不支持HTML5History方式（通过supportsPushState变量判断），则mode强制设为’hash’；若不是在浏览器环境下运行，则mode强制设为’abstract’</li><li>VueRouter类中的onReady(), push()等方法只是一个代理，实际是调用的具体history对象的对应方法，在init()方法中初始化时，也是根据history对象具体的类别执行不同操作<h3 id="Hashhistory"><a href="#Hashhistory" class="headerlink" title="Hashhistory"></a>Hashhistory</h3><blockquote><p>#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。它具有如下特点：</p></blockquote></li></ul><ol><li>虽然hash本身出现在URL,但不会被包括在http请求中。他是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash值不会重新加载页面，只会更新视图但不重新请求页面</li><li><p>可以为hash的改变添加监听事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;hashchange&apos;,funcRef,false);</span><br></pre></td></tr></table></figure></li><li><p>每一次hash改变都会在浏览器的历史记录添加一条记录<br><strong>history.push和history.replace</strong><br>每次访问新的hash就是通过这两个其中一个将其推到历史访问栈中的，他们的根本区别是，replace并不是将新路由添加到浏览器的栈顶，而是替换掉当前的路由</p><h3 id="Html5-History"><a href="#Html5-History" class="headerlink" title="Html5 History"></a>Html5 History</h3><p>这是另外一种路由模式，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：<br>这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求该URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><p>hashhistory和html5history的根本区别是第一种模式多了个#号，其实history.pushState相比于直接修改hash主要有一下优势</p></li></ol><ul><li>pushState设置新的url可以是与当前URL同源的任意URL,而hash只可以修改hash后面的内容，故只可以设置与当前同文档的URL</li><li>pushState可以设置与当前的url一模一样，这样也会被记录到栈中，而hash设置的新值必须与原来的不一样才会触发记录添加到栈中<h3 id="history模式的一个问题"><a href="#history模式的一个问题" class="headerlink" title="history模式的一个问题"></a>history模式的一个问题</h3>我们知道对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏中输入并回车，浏览器重启重新加载应用等。<br>hash模式仅改变hash部分的内容，而hash部分是不会包含在HTTP请求中的：</li></ul><blockquote><p><a href="http://oursite.com/#/user/id" target="_blank" rel="noopener">http://oursite.com/#/user/id</a>   // 如重新请求只会发送<a href="http://oursite.com/" target="_blank" rel="noopener">http://oursite.com/</a></p></blockquote><p>故在hash模式下遇到根据URL请求页面的情况不会有问题。<br>而history模式则会将URL修改得就和正常请求后端的URL一样</p><blockquote><p><a href="http://oursite.com/user/id" target="_blank" rel="noopener">http://oursite.com/user/id</a></p></blockquote><p>在此情况下重新向后端发送请求，如后端没有配置对应/user/id的路由处理，则会返回404错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p><blockquote><p>转载自<a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="noopener">此处</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
            <tag> history </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React入门爬坑记（一）</title>
      <link href="/2018/08/30/React_1/"/>
      <url>/2018/08/30/React_1/</url>
      
        <content type="html"><![CDATA[<p> React是众多前端开发中较为青睐的框架，但是相对于其他，React的学习成本相对比较高，但是在适合的场景下通过React开发出来的产品性能以及结构会比较好<a id="more"></a></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>地址：<a href="https://github.com/chenjiaobin/react_demo" target="_blank" rel="noopener">https://github.com/chenjiaobin/react_demo</a></p><h3 id="安装全局依赖"><a href="#安装全局依赖" class="headerlink" title="安装全局依赖"></a>安装全局依赖</h3><p>首先在开始使用React之前我们需要安装相应的依赖</p><ul><li>全局安装React<code>npm install react -g</code></li><li>全局安装react-dom <code>npm install react-dom -g</code></li><li>全局安装webpack-dev-server <code>npm install webpack-dev-server -g</code>这个是为了作为前端开发的服务</li><li>全局安装webpack <code>npm install webpack -g</code>这个是项目打包工具<h3 id="创建项目以及安装项目依赖"><a href="#创建项目以及安装项目依赖" class="headerlink" title="创建项目以及安装项目依赖"></a>创建项目以及安装项目依赖</h3></li></ul><ol><li>通过<code>npm init</code>生成package.json，并填写相应的配置信息，最终生成package.json文件</li><li><p>安装项目依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-core&quot;: &quot;^6.26.3&quot; //这个是babel的核心，一下的babel相关都是为了转码es6和react</span><br><span class="line">&quot;babel-loader&quot;: &quot;^7.1.4&quot;</span><br><span class="line">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;</span><br><span class="line">&quot;babel-preset-react&quot;: &quot;^6.24.1&quot;</span><br><span class="line">&quot;babelify&quot;: &quot;^8.0.0&quot;</span><br><span class="line">&quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;  //这个是为了热更新加上的，每次更改代码会重新打包html</span><br><span class="line">&quot;react&quot;: &quot;^16.4.0&quot;</span><br><span class="line">&quot;react-dom&quot;: &quot;^16.4.0&quot;</span><br><span class="line">&quot;webpack&quot;: &quot;^4.10.2&quot;</span><br><span class="line">&quot;webpack-dev-server&quot;: &quot;^3.1.4&quot; //项目的微服务</span><br><span class="line">&quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;  //使用es7feature,在这个demo是为了解决react中static状态报错</span><br><span class="line">&quot;bower-webpack-plugin&quot;: &quot;^0.1.9&quot;</span><br><span class="line">&quot;open-browser-webpack-plugin&quot;: &quot;^0.0.5&quot; //编译完项目自动打开浏览器</span><br><span class="line">&quot;prop-types&quot;: &quot;^15.6.1&quot; //react在15.5.0版本以后就将propType移除，被独立成一个新的包prop-type,所以需要安装prop-types,并在组件中import进来</span><br><span class="line">&quot;react-mixin&quot;: &quot;^2.0.2&quot;  //在es6语法的基类中不能使用mixin，所以只能通过第三方插件来解决这个问题</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^3.0.1&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置webpack,新建文件webpack.config.js,内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">// 打包html</span><br><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var OpenBrowserPlugin = require(&apos;open-browser-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  entry: path.join(__dirname,&apos;/src/index.js&apos;),//这是入口文件，你需要在src文件夹下创建index.js入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname + &apos;/build&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">  port: 8080,</span><br><span class="line">  contentBase: &apos;./src&apos;, //src文件夹里面的内容改变就会重新打包</span><br><span class="line">  historyApiFallback: true,</span><br><span class="line">  hot: true,</span><br><span class="line">  inline: true //devServer有iframe(默认)和inline模式</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js?$/,//表示要编译的文件的类型，这里要编译的是js文件</span><br><span class="line">        loader: &apos;babel-loader&apos;,//装载的哪些模块</span><br><span class="line">        exclude: /node_modules/,//标示不编译node_modules文件夹下面的内容</span><br><span class="line">        query: &#123;//具体的编译的类型，</span><br><span class="line">            compact: true,//表示不压缩</span><br><span class="line">            presets: [&apos;es2015&apos;, &apos;react&apos;, &apos;stage-0&apos;]//我们需要编译的是es6和react,stage-0这个插件是为了解决静态属性static</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &quot;This is the result&quot;,</span><br><span class="line">        filename: &quot;./index.html&quot;,</span><br><span class="line">        template: &quot;./index.html&quot;</span><br><span class="line">  &#125;),</span><br><span class="line">    new OpenBrowserPlugin(&#123; url: &apos;http://localhost:8080&apos; &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建入口文件,demo文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var React = require(&apos;react&apos;)</span><br><span class="line">var ReactDom = require (&apos;react-dom&apos;)</span><br><span class="line">import ComponentHeader from  &apos;./components/header.js&apos;</span><br><span class="line">import ComponentBody from  &apos;./components/bodyIndex.js&apos;</span><br><span class="line">import ComponentBottom from  &apos;./components/footer.js&apos;</span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ComponentHeader name=&quot;我是阿布&quot;/&gt;</span><br><span class="line">        &lt;ComponentBody userId=&#123;123456&#125; sex=&quot;male&quot;/&gt;</span><br><span class="line">        &lt;ComponentBottom/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;Index/&gt;,</span><br><span class="line">    document.getElementById(&apos;app&apos;)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p>再将对应的组件创建出来，详情代码请看<a href="https://github.com/chenjiaobin/react_demo" target="_blank" rel="noopener">demo</a></p></li><li>开始打包,在控制台执行<code>webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline --content-base ./build</code>，这个我已经在package.json配置好了，所以如果在使用demo的时候直接使用<code>npm run dev</code>就好了<h3 id="React的坑"><a href="#React的坑" class="headerlink" title="React的坑"></a>React的坑</h3>参考地址： <a href="https://segmentfault.com/a/1190000005863630" target="_blank" rel="noopener">地址</a><blockquote><p>React.createClass和React.Component的区别(React.createClass在16.0版本以后已经被废除了)</p></blockquote></li></ol><ul><li>语法区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 注意：组件名字的首字母大写，如Mydemo</span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">// 这个是React.createClass的语法</span><br><span class="line">const Mydemo = React.createClass(&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;这个是demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default Mydemo</span><br><span class="line"></span><br><span class="line">// 这个是React.Component的语法</span><br><span class="line">export default class Mydemo2 extends React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (&#123;</span><br><span class="line">            &lt;div&gt;这个事React.Component的语法&lt;/div&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>propType 和 getDefaultProps<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</span><br><span class="line"></span><br><span class="line">const Mydemo = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;</span><br><span class="line">        name: React.PropTypes.string //设置props中name的类型</span><br><span class="line">    &#125;</span><br><span class="line">    getDefaultProps() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;陈焦滨&amp;kevin&apos; //设置props中name的默认值</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;这个是demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// React.Component：通过设置两个属性propTypes和defaultProps</span><br><span class="line"></span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line">export default class Mydemo2 extends React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">    &#125;</span><br><span class="line">    // 在propTypes在15.5.0版本以后就被移除了，被单独封装成一个包prop-type,用的时候需要安装依赖prop-types</span><br><span class="line">    //static propTypes = &#123;</span><br><span class="line">    //   name: React.PropTypes.string</span><br><span class="line">    //&#125;;</span><br><span class="line">    //使用static的时候记得安装babel-preset-stage-0</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        name: &apos;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (&#123;</span><br><span class="line">            &lt;div&gt;这个事React.Component的语法&lt;/div&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用这个之前需要先安装依赖prop-types</span><br><span class="line">Mydemo2.propTypes  = &#123;</span><br><span class="line">userId: PropTypes.number.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>状态state的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// React.createClass：通过getInitialState()方法返回一个包含初始值的对象</span><br><span class="line">const Mydemo = React.createClass(&#123;</span><br><span class="line">    // 初始化state数据,这个在es6中的class就失效了，直接可以通过在constructor设置state</span><br><span class="line">    getInitialState()&#123; </span><br><span class="line">        return &#123;</span><br><span class="line">            isEditing: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;这个是demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default class Mydemo2 extends React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            name: &apos;陈焦滨&amp;kevin&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (&#123;</span><br><span class="line">            &lt;div&gt;这个事React.Component的语法&lt;/div&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>this区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// React.createClass：会正确绑定this</span><br><span class="line">const Mydemo = React.createClass(&#123;</span><br><span class="line">    handlerFun () &#123;</span><br><span class="line">        console.log(&apos;测试&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &#123;/*这是注释：这里的点击事件不用绑定this，createClas这种方式的this已经是指到当前实例*/&#125;</span><br><span class="line">            &lt;div onClick=&quot;this.handlerFun&quot;&gt;这个是demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</span><br><span class="line">export default class Mydemo2 extends React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            name: &apos;我是state参数&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        // 推荐这种绑定方式，因为在这里只需要绑定一次就好了，如果是在render里面绑定，每一次调用render(可以说是非常频繁！)一个新的函数都会被创建。与在构造函数里只绑定一次相比就慢一些</span><br><span class="line">        // this.handlerFun = this.handlerFun.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    handlerFun (val) &#123;</span><br><span class="line">        console.log(val)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (&#123;</span><br><span class="line">            &#123;/*这里通过bind绑定this*/&#125;</span><br><span class="line">            &lt;div onClick=&quot;this.handlerFun.bind(this,&apos;我是参数&apos;)&quot;&gt;这个事React.Component的语法&lt;/div&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 还可以通过箭头函数直接替换函数在类中的声明，这是es7的方式</span><br><span class="line">export default class MyDemo2 extends React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            name: &apos;我是初始值&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const handerFun = (event) = &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            name:&apos;我被改变了&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>mixin的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// React.createClass：使用 React.createClass 的话，我们可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。</span><br><span class="line">// 创建一个文件MxinCommon.js</span><br><span class="line">let MyMixin = &#123;</span><br><span class="line">    doSomething()&#123;</span><br><span class="line">        console.log(&apos;我是mixin&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default MyMixin</span><br><span class="line"></span><br><span class="line">// React.createClass</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import MyMixin from &apos;./MxinCommon.js&apos;</span><br><span class="line">let TodoItem = React.createClass(&#123;</span><br><span class="line">    mixins: [MyMixin]</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// React.Component,es6没有mixin这种混合，只能通过第三方插件react-mixin来使用，安装完这个依赖后就可以使用啦</span><br><span class="line">import ReactMixin from &apos;react-mixin&apos;</span><br><span class="line">import mixinLog from &apos;./MxinCommon.js&apos;</span><br><span class="line">export default class MyDemo2 React.Component &#123;</span><br><span class="line">    constructor (props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.handler = this.handler.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    handler () &#123;</span><br><span class="line">        mixinLog.doSomething() //这样就调用到mixin的方法了</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&quot;this.handler&quot;&gt;&lt;/div&gt;    </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactMixin(MyDemo2.prototype, mixinLog)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>祝各位前端开发的小伙伴爬坑快乐 <a name=":blush:"></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串行和并行</title>
      <link href="/2018/04/19/JS%E5%AE%9E%E7%8E%B0%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/04/19/JS%E5%AE%9E%E7%8E%B0%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>在实际开发中有时获取数据是相互依赖的，这就需要用到请求中的串行和并行请求了<a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>串行请求</p></blockquote><p>实际就是一个请求执行完之后再执行另外一个请求</p><blockquote><p>并行请求</p></blockquote><p>实际就是几个请求同时执行完成后，再执行某个操作</p><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p><strong>方式：</strong>串行执行的方式有两种，一种是按顺序写请求函数，然后将其请求设置成同步(async=false)，另外一种就是可以不按顺序写，但是要设置成异步发送(async=true)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//串行执行分两种。  </span><br><span class="line">//一是用同步模式async: false，三个ajax请求连着写就可以了。  </span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&apos;请求1&apos;,</span><br><span class="line">  async:false,  //这个是重点</span><br><span class="line">  success:function()&#123;</span><br><span class="line">    console.log(&apos;请求1完成&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&apos;请求2&apos;,</span><br><span class="line">  async:false,  //这个是重点</span><br><span class="line">  success:function()&#123;</span><br><span class="line">    console.log(&apos;请求2完成&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&apos;请求3&apos;</span><br><span class="line">  async:false,  //这个是重点</span><br><span class="line">  success:function()&#123;</span><br><span class="line">    console.log(&apos;请求3完成&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//二是用异步模式async: true，三个ajax请求嵌套写，ES6可以通过then链来实现嵌套，ES7可以通过async/await来实现同样的嵌套，会更简单</span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &quot;ajax请求1&quot;,  </span><br><span class="line">    async: true,  </span><br><span class="line">    success: function (data) &#123;  </span><br><span class="line">        console.log(&quot;ajax请求1 完成&quot;);  </span><br><span class="line">        $.ajax(&#123;  </span><br><span class="line">            url: &quot;ajax请求2&quot;,  </span><br><span class="line">            async: true,  </span><br><span class="line">            success: function (data) &#123;  </span><br><span class="line">                console.log(&quot;ajax请求2 完成&quot;);  </span><br><span class="line">                $.ajax(&#123;  </span><br><span class="line">                    url: &quot;ajax请求3&quot;,  </span><br><span class="line">                    async: true,  </span><br><span class="line">                    success: function (data) &#123;  </span><br><span class="line">                        console.log(&quot;ajax请求3 完成&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">//用async/await</span><br><span class="line">async function sendAjax()&#123;</span><br><span class="line">  let a=await func1();</span><br><span class="line">  let b=await func2();</span><br><span class="line">  func3(a,b);//这一步会等到前两个请求完成之后才会执行这一步，应为await会阻塞后面代码的执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p><strong>方式：</strong>只能通过异步模式来实现,并设置变量进行计数，ES6的Promise.all也可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var num = 0;</span><br><span class="line">function isAllSuccess()&#123;</span><br><span class="line">  num++;</span><br><span class="line">  if(num&gt;=3)&#123;</span><br><span class="line">    console.log(&apos;三个请求已经完成了&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &quot;ajax请求1&quot;,  </span><br><span class="line">    async: true,  //设置成异步</span><br><span class="line">    success: function (data) &#123;  </span><br><span class="line">        console.log(&quot;ajax请求1 完成&quot;);  </span><br><span class="line">        isAllSuccess();  //下面的每个请求都需要带上他进行计数</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &quot;ajax请求2&quot;,  </span><br><span class="line">    async: true,  </span><br><span class="line">    success: function (data) &#123;  </span><br><span class="line">        console.log(&quot;ajax请求3 完成&quot;);  </span><br><span class="line">        isAllSuccess();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &quot;ajax请求3&quot;,  </span><br><span class="line">    async: true,  </span><br><span class="line">    success: function (data) &#123;  </span><br><span class="line">        console.log(&quot;ajax请求3 完成&quot;);  </span><br><span class="line">        isAllSuccess();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串行 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async和await</title>
      <link href="/2018/04/15/async%E5%92%8Cawait/"/>
      <url>/2018/04/15/async%E5%92%8Cawait/</url>
      
        <content type="html"><![CDATA[<p>async和await作为ES7新的API,解决了异步编程过程中的很多问题，在Node.js V7也添加了对这两个API的支持。<a id="more"></a></p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>如果async函数直接return出来一个普通值<code>async function a(){return &#39;hello&#39;}</code>，执行完a函数后返回的是一个promise对象，也就是说async会把这个直接量通过Promise.resolve封装成一个Promise对象，那么其实我们可以通过then这种方式来接受promise的值，然后在then里面输出来<code>a().then((v)=&gt;{console.log(v)})</code><br><br><font color="#ff0000">注意：async始终返回的是一个Promise对象</font></p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await这个则是在async内部调用的一个接口，一般后面接的也是一个返回promise的函数，当然也可以是直接量或者是普通函数，<font color="#FF0000">但是</font>，如果await等到的不是promise的话，那么await表达式的运算结果就是它得到的值，如果等到的是Promise对象的话，那么await就忙起来了，它会阻塞后面的代码的执行，等着Promise的resolve，然后得到resolve的值，这个值就是await的值<font color="#ff0000">(这里的阻塞就是await必须用在async里面的原因了，async函数的调用不会造成阻塞，它内部所有的阻塞都是封装在Promise对象中异步执行)</font><br>await的promise对象有可能运行结果是rejected，所以最好把await命令放在try…catch里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function test()&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">     await demo();</span><br><span class="line">  &#125;.catch(err)&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//另外一种写法是</span><br><span class="line">async function test()&#123;</span><br><span class="line">  await demo().catch&#123;function(err)&#123;console.log(err)&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">  //上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</span><br><span class="line">  async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</span><br></pre></td></tr></table></figure></p><p>上面的这个例子就给我们引出了另外一个问题，<strong>并行处理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  for (let doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</span><br><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  let promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  let results = await Promise.all(promises);</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用下面的写法</span><br><span class="line"></span><br><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  let promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  let results = [];</span><br><span class="line">  for (let promise of promises) &#123;</span><br><span class="line">    results.push(await promise);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="async-await的优势"><a href="#async-await的优势" class="headerlink" title="async/await的优势"></a>async/await的优势</h3><p>async/await 的优势在于处理 then 链，<br>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//单一的Promise</span><br><span class="line">function task()&#123;</span><br><span class="line">  return new Promise(resolve=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;resolve(&apos;这个是延时显示的内容&apos;)&#125;,1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">task().then(v=&gt;&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">//用await代替实现</span><br><span class="line">async function demo()&#123;</span><br><span class="line">  const v=await task();</span><br><span class="line">  console.log(v);//这个只有等到上面await函数的内容执行完才会到这一步，这就是被阻塞了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面看出来其实单一的promise发挥不出async的优点。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="line"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="line"> */</span><br><span class="line">function takeLongTime(n) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step1(n) &#123;</span><br><span class="line">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step2(n) &#123;</span><br><span class="line">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step3(n) &#123;</span><br><span class="line">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">//用普通的promise来实现</span><br><span class="line">function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(time2 =&gt; step2(time2))</span><br><span class="line">        .then(time3 =&gt; step3(time3))</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">            console.log(`result is $&#123;result&#125;`);</span><br><span class="line">            console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line">//可以看出promise不断的通过then调用下一个函数来完成自己的目的</span><br><span class="line">//通过async/await来实现</span><br><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    const time2 = await step1(time1);//只有这一步执行完才会执行下一步，这样下一步就能去到上一步的返回的值了</span><br><span class="line">    const time3 = await step2(time2);</span><br><span class="line">    const result = await step3(time3);</span><br><span class="line">    console.log(`result is $&#123;result&#125;`);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure></p><h3 id="Generator与yield"><a href="#Generator与yield" class="headerlink" title="Generator与yield"></a>Generator与yield</h3><p>async 函数是 Generator 函数的语法糖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//通过generator和yield来实现文件的读取</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var readFile = function (fileName) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, function(error, data) &#123;</span><br><span class="line">      if (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = function* () &#123;</span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">//接下来通过async/await来实现</span><br><span class="line">var async ReadFile = async function () &#123;</span><br><span class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><font color="#ff0000">async函数就是将 Generator 函数的星号（*)替换成async，将yield替换成await，仅此而已。</font><br><br><strong>async的优点</strong></p><ul><li>内置执行器：generator需要依靠执行器，所以才有了CO函数库(这个是TJ大神写的一个使用生成器函数来解决异步流程问题，可以看做是生成器函数执行器),但是async有自带执行器</li><li>语义更好</li><li>更广的适用性:co函数库规定，yield后面跟的是Thunk函数或Promise对象,但是await后面则可以是promise对象或者原始数据类型(数值\字符串\布尔值，但是这是属于同步操作)<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">文档1</a><br><a href="https://www.cnblogs.com/zczhangcui/p/6636885.html" target="_blank" rel="noopener">文档2</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">文档3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol.iterator</title>
      <link href="/2018/04/13/Symbol.iterator/"/>
      <url>/2018/04/13/Symbol.iterator/</url>
      
        <content type="html"><![CDATA[<p>如果学过设计模式和java的人都知道iterator是什么东西，在Symbol.iterator出现后，JS可以定义自己的迭代器<a id="more"></a></p><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>迭代器，它是用于访问集合类的标准访问方法，它可以把访问逻辑从不同类型集合中抽象出来，从而避免向外部暴露集合内部的结构。比如我们访问一个数组可能使用for循环或者map,foreach,filter等<code>for(int i=0; i&lt;array.size(); i++) { ... get(i) ... }</code>， 但是当我们想要遍历链表(linkedlist)的时候就得使用while循环<code>while((e=e.next())!=null) { ... e.data() ... }</code>, 以上两种方式我们都必须知道集合的内部结构是怎么样的我们才可以使用对应的循环方式去循环整个集合，那么这样就造成了很大的耦合度，当我们把一个集合的类型从Arrarlist变成Linkedlist的时候，那么原来客户端的代码必须重写，因为我们集合变了，遍历的方式也必须改成对应的方式。为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合： <code>for(Iterator it = c.iterater(); it.hasNext(); ) { ... }</code></p><h3 id="for-of和for-in的区别"><a href="#for-of和for-in的区别" class="headerlink" title="for-of和for-in的区别"></a>for-of和for-in的区别</h3><p>遍历数组通常使用for循环，ES5的话也可以使用forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，只不过他们的返回结果不一样。但是使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myArray=[1,2,4,5,6,7]</span><br><span class="line">myArray.name=&quot;杀马特&quot;</span><br><span class="line">Array.prototype.method=function()&#123;</span><br><span class="line">　　console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">for (var index in myArray) &#123;</span><br><span class="line">  console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用for in 也可以遍历数组，但是会存在以下问题：</p><ol><li>index索引为字符串型数字，不能直接进行几何运算</li><li>遍历顺序有可能不是按照实际数组的内部顺序</li><li>使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性<br>所以for in更适合遍历对象，不要使用for in遍历数组。</li></ol><p>那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），ES6中的for of更胜一筹.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myArray=[1,2,4,5,6,7]</span><br><span class="line">myArray.name=&quot;杀马特&quot;</span><br><span class="line">Array.prototype.method=function()&#123;</span><br><span class="line">　　console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">for (var index of myArray) &#123;  //这里的index输出的是value而不是索引</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#dd0000">注意:for-of目前js实现的对象有array，string，argument以及后面更高级的set，Map</font><br>当我们遍历对象的时候可以使用for-in，不过这种遍历方式会把原型上的属性和方法也给遍历出来，当然我们可以通过<code>hasOwnProperty</code>来过滤掉除了实例对象的数据，但是for-of在object对象上暂时没有实现，但是我们可以通过Symbol.iterator给对象添加这个塑性，我们就可以使用for-of了，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var p=&#123;</span><br><span class="line">name:&apos;kevin&apos;,</span><br><span class="line">age:2,</span><br><span class="line">sex:&apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(p,Symbol.iterator,&#123;</span><br><span class="line">enumberable:false,</span><br><span class="line">configurable:false,</span><br><span class="line">writable:false,</span><br><span class="line">value:function()&#123;</span><br><span class="line">var _this=this;</span><br><span class="line">var nowIndex=-1;</span><br><span class="line">var key=Object.keys(_this);</span><br><span class="line">return &#123;</span><br><span class="line">next:function()&#123;</span><br><span class="line">nowIndex++;</span><br><span class="line">return &#123;</span><br><span class="line">value:_this[key[nowIndex]],</span><br><span class="line">done:(nowIndex+1&gt;key.length)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//这样的话就可以直接通过for-of来遍历对象了</span><br><span class="line">for(var i of p)&#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">输出的是：kevin,2,male</span><br></pre></td></tr></table></figure></p><p>其实for-of的原理最终也是通过调用p[Symbol.iterator]()这个函数，这个迭代器函数返回一个next函数，for循环会不断调用next<br>那么知道原理之后，我们可以自己来调用iterator.next来实现循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var students = &#123;&#125;</span><br><span class="line">students[Symbol.iterator] = function() &#123;</span><br><span class="line">  let index = 1;</span><br><span class="line">  return &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">      return &#123;done: index&gt;100, value: index++&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var iterator = students[Symbol.iterator]();</span><br><span class="line">var s=iterator.next();</span><br><span class="line">while(!s.done) &#123;</span><br><span class="line">  console.log(s.value);</span><br><span class="line">  s=iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上例中使用 iterator.next 和 while 结合实现了 for循环。<br>除了使用iterator 之外，我们还可以使用 yield 语法来实现循环，yield相对简单一些，只要通过 yield 语句把值返回即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let students = &#123;</span><br><span class="line">  [Symbol.iterator]: function*() &#123;</span><br><span class="line">    for(var i=0;i&lt;=100;i++) &#123;</span><br><span class="line">      yield i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var s of students) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br><span class="line">//这个yield其实最后返回的就是iterator函数</span><br></pre></td></tr></table></figure></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/lihongxun945/article/details/48952017" target="_blank" rel="noopener">文档1</a><br><a href="https://blog.csdn.net/gjc9620/article/details/47681271" target="_blank" rel="noopener">文档2</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Symbol.iterator </tag>
            
            <tag> for-of </tag>
            
            <tag> for-in </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器兼容性问题</title>
      <link href="/2018/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这里总结了浏览器主要的兼容性问题<a id="more"></a></p><h3 id="css兼容性"><a href="#css兼容性" class="headerlink" title="css兼容性"></a>css兼容性</h3><blockquote><p>块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大</p><ul><li>问题症状:常见症状是ie6中后面的一块被顶到下一行</li><li>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</li><li>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</li><li>备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。<br>设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度</li><li>问题症状：ie6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</li><li>碰到频率：60%</li><li>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</li><li>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是ie8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。<br>图片默认有间距</li><li>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加上问题一中提到的通配符也不起作用。</li><li>碰到几率：20%</li><li>解决方案：使用float属性为img布局</li><li>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道<br>标签最低高度设置min-height不兼容</li><li>问题症状：因为min-height本身就是一个不兼容的css属性，所以设置min-height时不能很好的被各个浏览器兼容</li><li>碰到几率：5%</li><li>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</li><li>备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。<br>IE6下在使用margin:0 auto;无法使其居中       </li><li>解决办法：为其父容器设置text-align:center;</li></ul></blockquote><h3 id="js兼容性"><a href="#js兼容性" class="headerlink" title="js兼容性"></a>js兼容性</h3><p>1.标准的事件绑定方法函数为addEventListener，但IE下是attachEvent；</p><p>2.事件的捕获方式不一致，标准浏览器是由外至内，而IE是由内到外，但是最后的结果是将IE的标准定为标准</p><p>3.window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement</p><p>4.在低版本的IE中获取的日期处理函数的值不是与1900的差值，但是在高版本的IE中和标准浏览器保持了一致，获取的值也是与1900的差值。<br> 比如：var year= new Date().getYear();</p><p>5.ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject</p><p>6.IE中不能操作tr的innerHtml7.获得DOM节点的父节点、子节点的方式不同<br>其他浏览器：parentNode  parentNode.childNodes<br>IE：parentElement parentElement.children</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call和apply和bind</title>
      <link href="/2018/03/21/call%E5%92%8Capply%E5%92%8Cbind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/03/21/call%E5%92%8Capply%E5%92%8Cbind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>原生js模拟实现call和apply以及bind</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); // 1</span><br></pre></td></tr></table></figure><p>其实我们也可以通过以下方式实现（但是我们在对象里面多创建了一个函数的属性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    bar: function() &#123;</span><br><span class="line">        console.log(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); // 1</span><br></pre></td></tr></table></figure></p><p>那么我们可以通过这种思想来模拟实现一个call<br>1.将函数设为对象的属性<br>2.执行该函数<br>3.删除该函数<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function (context) &#123;</span><br><span class="line">  var context  = context || window</span><br><span class="line">  var context.fn = this // 这个this就是我们使用call的时候前面的函数，相当于上面的对象里面的bar函数</span><br><span class="line">  var arg = [].slice.call(arguments, 1) // 获取context后面的所有参数</span><br><span class="line">  var result = context.fn(...arg)</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;chenji&apos;</span><br><span class="line">&#125;</span><br><span class="line">function test () &#123;</span><br><span class="line"> var name = &apos;test&apos;</span><br><span class="line"> console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">test() //outPut  &apos;window&apos;</span><br><span class="line">test.call(obj, 12) // outPut  &apos;chenji&apos;</span><br></pre></td></tr></table></figure></p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p> apply和call很相似，只是传递参数的类型不一样<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function (context) &#123;</span><br><span class="line">  var context  = context || window</span><br><span class="line">  var context.fn = this // 这个this就是我们使用call的时候前面的函数，相当于上面的对象里面的bar函数</span><br><span class="line">  var result</span><br><span class="line">  // 判断是否有传入第二个参数，apply的第二个参数是数组，有的话就展开</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">     result = context.fn(..arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;chenji&apos;</span><br><span class="line">&#125;</span><br><span class="line">function test () &#123;</span><br><span class="line"> var name = &apos;test&apos;</span><br><span class="line"> console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">test() //outPut  &apos;window&apos;</span><br><span class="line">test.call(obj, 12) // outPut  &apos;chenji&apos;</span><br></pre></td></tr></table></figure></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p></blockquote><p> 例子<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var bindFoo = bar.bind(foo, &apos;daisy&apos;);</span><br><span class="line">bindFoo(&apos;18&apos;); </span><br><span class="line">// 1</span><br><span class="line">// daisy</span><br><span class="line">// 18</span><br></pre></td></tr></table></figure></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2=function(context)&#123;</span><br><span class="line">   if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">     throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   var self=this;</span><br><span class="line">   var arr=Array.prototype.slice.call(arguments,1);//因为第一个参数是作为它运行时的this，所以从第二个开始截取到末尾</span><br><span class="line">   return function()&#123;</span><br><span class="line">       var binArr=Array.prototype.slice.call(arguments);// 这个时候的arguments是指bind返回的函数传入的参数</span><br><span class="line">       return self.apply(context,arr.concat(binArr));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样还不是很全面，我们还可能通过对bind返回的函数进行实例化并传入参数,此时的this指向又发生了变化<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var value = 2;</span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    this.habit = &apos;shopping&apos;;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend = &apos;kevin&apos;;</span><br><span class="line">var bindFoo = bar.bind(foo, &apos;daisy&apos;);</span><br><span class="line">var obj = new bindFoo(&apos;18&apos;);</span><br><span class="line">// undefined</span><br><span class="line">// daisy</span><br><span class="line">// 18</span><br><span class="line">console.log(obj.habit);</span><br><span class="line">console.log(obj.friend);</span><br><span class="line">// shopping</span><br><span class="line">// kevin</span><br></pre></td></tr></table></figure></p><p> 完整版模拟实现bind<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if(typeof this !== &apos;Function&apos;)&#123;</span><br><span class="line">    throw new Error(&quot;this is a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var _this = this</span><br><span class="line">  var arg = [].slice.call(arguments,1)</span><br><span class="line">  return function F () &#123;</span><br><span class="line">    // 因为bind返回了一个函数，所以有可能使用new F(),就如上面的例子，所以需要通过以下这个来判断是否被实例化过，是的话就返回一个原函数的实例化对象来改变this的指向</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...arg, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, arg.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><blockquote><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> function a(func)&#123;</span><br><span class="line">   // 获取第一次执行时的参数</span><br><span class="line">   var arr=Array.prototype.slice.call(arguments,1);</span><br><span class="line">   var fn=function()&#123;</span><br><span class="line">    // 第二次执行才会进来这个函数里面</span><br><span class="line">         if(arguments.length===0)&#123;</span><br><span class="line">    return func.apply(this,arr);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">    for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class="line">       arr.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  return fn;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  return fn; </span><br><span class="line"> &#125;</span><br><span class="line">function add()&#123;</span><br><span class="line">  return Array.prototype.reduce.call(arguments,function(m,n)&#123;return m+n&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(add,1,2,3,4)(23,1)(3)()  //37  这里可以不断连接下去</span><br></pre></td></tr></table></figure></p></blockquote><p>bind函数的分装也是应用到了这个柯里化的这个技术，它还可以延1. 参数复用；2. 提前返回；3. 延迟计算/运行</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">文章1</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
            <tag> 函数柯里化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex和vue通信</title>
      <link href="/2018/03/11/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%92%8Cvuex/"/>
      <url>/2018/03/11/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%92%8Cvuex/</url>
      
        <content type="html"><![CDATA[<p>vue的核心内容是组件库和数据绑定，在组件的状态管理上vue通过vuex进行完美的融合，以及在vue通信上以单向数据流来进行传递数据<a id="more"></a></p><h3 id="vue通信"><a href="#vue通信" class="headerlink" title="vue通信"></a>vue通信</h3><p>vue2.0以上取消了之前的dispatch和broadcast的数据通信方式，也取消了子组件直接修改父组件数据的方式。现在组件之间的通信主要是通过$emit和$on，以及props的方式进行通信，当项目的复杂程度比较大的时候可以通过vuex状态管理插件来对组件进行状态的管理。</p><ol><li><p>父组件传递数据到子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :tochild=&quot;word&quot;&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        word:&apos;我是你父亲&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;tochild&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">   props:[&apos;tochild&apos;] //通过props接受父亲的东西</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件传递数据给父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    //@changeParent这个名字必须跟在子组件定义时的Key值要一样</span><br><span class="line">    &lt;child @changeParent=&quot;some&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        word:&apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      some(val)&#123;//这个val就是子组件传来的数据</span><br><span class="line">        this.word=val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;change&quot;&gt;我要改父亲的东西&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">   methods:&#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      somethig:&quot;我是要给父亲的&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   change()&#123;</span><br><span class="line">      this.$emit(&quot;changeParent&quot;,this.something);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件修改父组件的数据还可以通过对象的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//做法：父组件传递给子组件的数据是一个对象，因此其实传递到子组件的是一个引用，只要在子组件修改这个父组件传递过来的值就会同时修改父组件和子组件的这个值</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :tochild=&quot;word&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;word.a&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        word:&#123;a:&quot;陈焦滨&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;tochild.a&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;changeMe&quot;&gt;改变父组件传递过来的数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">   props:[&apos;tochild&apos;], //通过props接受父亲的东西</span><br><span class="line">   methods:&#123;</span><br><span class="line">    changeMe()&#123;</span><br><span class="line">      this.word.a=&quot;好帅啊&quot;;//这样就实现了子组件和父组件同步的问题</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>兄弟组件传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//兄弟组件之间的传递我们可能第一时间会想到从子组件传递数据到父组件，再从父组件传递数据到另外一个子组件，但是当我们的项目越来越大的时候，就会发现这种方式会引发很多问题，会变得不好维护</span><br><span class="line">//所以我们最好使用vuex状态管理或者以下方法，通过实例化一个vue对象，然后通过$emit发射,$on接收，如下</span><br><span class="line">a. 创建一个js文件，内容如下bus.js</span><br><span class="line">import vue from &apos;vue&apos;</span><br><span class="line">export default new vue();</span><br><span class="line">b. 子组件1</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;changeMe&quot;&gt;传数据给我兄弟&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &apos;../bus.js&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     word:&apos;这是给我兄弟的&apos;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods:&#123;</span><br><span class="line">    changeMe()&#123;</span><br><span class="line">      bus.$emit(&apos;msg&apos;,this.word);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">c. 组件2</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;some&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &apos;../bus.js&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     some:&apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   mounted()&#123;</span><br><span class="line">    var that=this;//切记，这个要加进去，要不在下面是取不到你这个实例里面的some的值的</span><br><span class="line">    bus.$on(&quot;msg&quot;,function(val)&#123;  //通过$on接收兄弟传过来的值</span><br><span class="line">     that.some=val;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">d. 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;child-one&gt;&lt;/child-one&gt;</span><br><span class="line">  &lt;child-two&gt;&lt;/child-two&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import childOne from &apos;../childOne&apos;</span><br><span class="line">import childTwo from &apos;../childTwo&apos;</span><br><span class="line">export default &#123;</span><br><span class="line"> components:&#123;</span><br><span class="line">  &apos;child-one&apos;:childOne,</span><br><span class="line">  &apos;child-two&apos;:childTwo</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="vuex状态管理"><a href="#vuex状态管理" class="headerlink" title="vuex状态管理"></a>vuex状态管理</h3><p>这个对于大型项目的组件的状态管理是非常方便的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//创建一个store文件夹，然后分别在这个文件夹下面创建mutation.js,action.js,store.js,getter.js,type.js(这个是用来存变量的)</span><br><span class="line">//type.js</span><br><span class="line">export  const  CHANGEDATA=&apos;CHANGEDATA&apos;;</span><br><span class="line">export const  INCREMENT=&quot;INCREMENT&quot;</span><br><span class="line">// action.js</span><br><span class="line">import * as  type from &apos;./type&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">changeMydata:(&#123;commit&#125;)=&gt;&#123;</span><br><span class="line">commit(type.CHANGEDATA);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//mutation.js</span><br><span class="line">import getters from &quot;./getter&quot;</span><br><span class="line">import &#123;CHANGEDATA,INCREMENT&#125; from &apos;./type&apos;</span><br><span class="line">const state=&#123;</span><br><span class="line">count:0</span><br><span class="line">&#125;</span><br><span class="line">const mutations=&#123;</span><br><span class="line">[CHANGEDATA](state)&#123;</span><br><span class="line">state.count++;</span><br><span class="line">&#125;</span><br><span class="line">// 相當於</span><br><span class="line">// CHANGEDATA:(state)=&gt;&#123;</span><br><span class="line">// state.count++</span><br><span class="line">// &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">//注意，下面这个名字必须这样写，不要写错了</span><br><span class="line">state,</span><br><span class="line">mutations,</span><br><span class="line">getters</span><br><span class="line">&#125;</span><br><span class="line">//getter.js</span><br><span class="line">export default &#123;</span><br><span class="line">getCount:(state)=&gt;&#123;</span><br><span class="line">return  state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">import actions from &apos;./actions&apos;</span><br><span class="line">import mutation from &apos;./mutation&apos;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">modules:&#123;</span><br><span class="line">mutation</span><br><span class="line">&#125;,</span><br><span class="line">actions</span><br><span class="line">&#125;)</span><br><span class="line">//最后在main.js入口文件引入我们的store.js就ok了</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  store:stores, //注意,这里的store也不要写错了</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>以上是个人的一些常用方式，有什么纰漏希望指点</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
            <tag> $emit </tag>
            
            <tag> props </tag>
            
            <tag> $on </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-resource</title>
      <link href="/2018/03/09/vue-resource/"/>
      <url>/2018/03/09/vue-resource/</url>
      
        <content type="html"><![CDATA[<p>vue-resource作为vue请求发送的一个插件<a id="more"></a></p><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;getSend&quot;&gt;点击发送&lt;/button&gt;</span><br><span class="line">method:&#123;</span><br><span class="line">  getSend:function()&#123;</span><br><span class="line">    this.$http.get(&apos;../a.json&apos;,&#123;b:2,c:3&#125;).then(function(res)&#123;</span><br><span class="line">      //成功</span><br><span class="line">    &#125;,function(res)&#123;</span><br><span class="line">      //失败</span><br><span class="line">      console.log(res.status)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;button @click=&quot;postSend&quot;&gt;点击发送&lt;/button&gt;</span><br><span class="line">method:&#123;</span><br><span class="line">  postSend:function()&#123;</span><br><span class="line">  //emulateJSON设置头，post必须设置</span><br><span class="line">    this.$http.get(&apos;../a.json&apos;,&#123;b:2,c:3&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123;</span><br><span class="line">      //成功</span><br><span class="line">    &#125;,function(res)&#123;</span><br><span class="line">      //失败</span><br><span class="line">      console.log(res.status)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;jsonSend&quot;&gt;点击发送&lt;/button&gt;</span><br><span class="line">method:&#123;</span><br><span class="line">  jsonSend:function()&#123;</span><br><span class="line">    this.$http.jsonp(&apos;../a.json&apos;,&#123;</span><br><span class="line">      params:&#123;</span><br><span class="line">        a:1,</span><br><span class="line">        b:2</span><br><span class="line">      &#125;,</span><br><span class="line">      jsonp:&apos;cb&apos;//这个值要看后台返回的回调函数名是什么，默认callback</span><br><span class="line">    &#125;).then(function(res)&#123;</span><br><span class="line">      //成功</span><br><span class="line">    &#125;,function(res)&#123;</span><br><span class="line">      //失败</span><br><span class="line">      console.log(res.status)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue-resource的另外一种配置发送请求"><a href="#vue-resource的另外一种配置发送请求" class="headerlink" title="vue-resource的另外一种配置发送请求"></a>vue-resource的另外一种配置发送请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;getSend&quot;&gt;点击发送&lt;/button&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">  getSend:function()&#123;</span><br><span class="line">    this.$http(&#123;</span><br><span class="line">      url:&apos;&apos;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        a:1,</span><br><span class="line">        b:2</span><br><span class="line">      &#125;,</span><br><span class="line">      method:&apos;post&apos;</span><br><span class="line">      jsonp:&apos;cb&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-resource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复选框设置背景</title>
      <link href="/2018/03/04/%E5%A4%8D%E9%80%89%E6%A1%86%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF/"/>
      <url>/2018/03/04/%E5%A4%8D%E9%80%89%E6%A1%86%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>更改复选框的默认样式<a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;chec&lt;/title&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #container &#123;</span><br><span class="line">                margin: 20px auto;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            #container span &#123;</span><br><span class="line">                position: relative;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            #container .input_check &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                visibility: hidden;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            #container .input_check+label &#123;</span><br><span class="line">                display: inline-block;</span><br><span class="line">                width: 16px;</span><br><span class="line">                height: 16px;</span><br><span class="line">                border: 1px solid #fd8845;</span><br><span class="line">            &#125;</span><br><span class="line">            #container .input_check:checked+label&#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">            #container .input_check:checked+label:after &#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                position: absolute;</span><br><span class="line">                left: 2px;</span><br><span class="line">                bottom: 12px;</span><br><span class="line">                width: 9px;</span><br><span class="line">                height: 4px;</span><br><span class="line">                border: 2px solid #fd8845;</span><br><span class="line">                border-top-color: transparent;</span><br><span class="line">                border-right-color: transparent;</span><br><span class="line">                -ms-transform: rotate(-60deg);</span><br><span class="line">                -moz-transform: rotate(-60deg);</span><br><span class="line">                -webkit-transform: rotate(-60deg);</span><br><span class="line">                transform: rotate(-45deg);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;body&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;h3&gt;利用css的：after跟transform属性代替checkbox效果&lt;/h3&gt;</span><br><span class="line">        &lt;div id=&quot;container&quot;&gt;</span><br><span class="line">            &lt;span&gt;&lt;input type=&quot;checkbox&quot;class=&quot;input_check&quot; id=&quot;check3&quot;&gt;&lt;label for=&quot;check3&quot;&gt;&lt;/label&gt;&lt;/span&gt;</span><br><span class="line">            &lt;span&gt;&lt;input type=&quot;checkbox&quot;class=&quot;input_check&quot; id=&quot;check4&quot;&gt;&lt;label for=&quot;check4&quot;&gt;&lt;/label&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> checkbox </tag>
            
            <tag> transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2018/03/04/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/03/04/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>懒加载（LazyLoad）是前端优化的一种有效方式，极大的提升用户体验，图片一直是页面加载的流浪大户，现在一张图片几兆已经是很正常的事，远远大于代码的大小。倘若一次ajax请求过来10张图片的地址，我想如果你一次性把10张图片都加载出来，肯定是不合理的。<a id="more"></a></p><h3 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h3><p>为了提高页面的加载速度和提高用户的体验效果，我们在加载图片的时候可以将未在用户视觉范围内的图片先不加载，等到滚动到视觉范围内时才去加载</p><h3 id="懒加载原理"><a href="#懒加载原理" class="headerlink" title="懒加载原理"></a>懒加载原理</h3><p>原理很简单，先把img的src指向空或者一个小图片，图片真实的地址存储在img一个自定义的属性里,&lt; img src=”” data-src=”<a href="http://real.com/real.jpg”" target="_blank" rel="noopener">http://real.com/real.jpg”</a> /&gt;,等到此图片出现在视野范围内了，获取img元素，把data-src里的值赋给src。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;lazy&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">img&#123;</span><br><span class="line">display: block;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/a.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/b.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/c.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/d.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/e.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; data-src=&quot;./img/f.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">var dom=document.querySelectorAll(&quot;img&quot;);</span><br><span class="line">var len=dom.length;</span><br><span class="line">var n=0;</span><br><span class="line">var flag=true;//这个是为了节流的</span><br><span class="line">function loadImg()&#123;</span><br><span class="line">flag=true;</span><br><span class="line">var clientHeight=document.documentElement.clientHeight;</span><br><span class="line">var scrollAddScroll=document.body.scrollTop||document.documentElement.scrollTop;</span><br><span class="line">for(var i=n;i&lt;len;i++)&#123;</span><br><span class="line">if(dom[i].offsetTop&lt;clientHeight+scrollAddScroll)&#123;</span><br><span class="line">if(dom[i].getAttribute(&quot;src&quot;)==&quot;&quot;)&#123;</span><br><span class="line">var datasrc=dom[i].getAttribute(&quot;data-src&quot;);</span><br><span class="line">dom[i].src=datasrc;</span><br><span class="line">&#125;</span><br><span class="line">n=n+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">loadImg();</span><br><span class="line">window.onscroll=function()&#123;</span><br><span class="line">if(!flag)&#123; //这个判断主要是为了提高性能，也是js节流的体现</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">flag=false;</span><br><span class="line">setTimeout(loadImg,1000)</span><br><span class="line">console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrollTop </tag>
            
            <tag> clientHeight </tag>
            
            <tag> 节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子垂直居中</title>
      <link href="/2018/02/26/%E7%9B%92%E5%AD%90%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2018/02/26/%E7%9B%92%E5%AD%90%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="定位方式-盒子宽高已知"><a href="#定位方式-盒子宽高已知" class="headerlink" title="定位方式(盒子宽高已知)"></a>定位方式(盒子宽高已知)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">left:50%;</span><br><span class="line">top:50px;</span><br><span class="line">margi-left:-(自身宽度的一半)</span><br><span class="line">margin-top:-(自身高度的一半)</span><br></pre></td></tr></table></figure><h3 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//父级</span><br><span class="line">display:table-cell;</span><br><span class="line">vertical:center;</span><br><span class="line">height:200px;</span><br><span class="line">width:300px;</span><br><span class="line">//子级</span><br><span class="line">margin:0 auto</span><br></pre></td></tr></table></figure><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">display:-webkit-flex;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content:center;</span><br></pre></td></tr></table></figure><h3 id="trabsform-适用于子盒子宽高不确定的"><a href="#trabsform-适用于子盒子宽高不确定的" class="headerlink" title="trabsform(适用于子盒子宽高不确定的)"></a>trabsform(适用于子盒子宽高不确定的)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//父亲</span><br><span class="line">position:relative;</span><br><span class="line">width:500px;</span><br><span class="line">height:200px;</span><br><span class="line">//子级</span><br><span class="line">position:absolute;</span><br><span class="line">top:50%;</span><br><span class="line">left:50%;</span><br><span class="line">transform:translate(50%,50%)//注意：这里启用了3D加速，会比较消耗CPU资源</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
            <tag> position </tag>
            
            <tag> table-cell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2018/02/11/vue/"/>
      <url>/2018/02/11/vue/</url>
      
        <content type="html"><![CDATA[<p>vue是当前比较火的框架之一，给我们前端开发减轻了很多dom上的操作以及数据的绑定等，注重逻辑的处理<a id="more"></a></p><h3 id="vue生命周期是什么"><a href="#vue生命周期是什么" class="headerlink" title="vue生命周期是什么"></a>vue生命周期是什么</h3><blockquote><p>vue有一个完整的生命周期，从实例的创建、初始化数据、编译模板、挂载dom模板、渲染-更新-渲染、卸载，通俗点讲就是vue从实例创建开始到销毁的过程，就是我们说的生命周期</p></blockquote><p><img src="https://raw.githubusercontent.com/chenjiaobin/chenjiaobin.github.io/Source/themes/raytaylorism/source/css/images/vue.jpg" alt="vue生命周期图"></p><p><strong>beforeCreate</strong></p><blockquote><p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p></blockquote><p><strong>created</strong></p><blockquote><p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p></blockquote><p><strong>beforeMount</strong></p><blockquote><p>dom挂载之前被调用</p></blockquote><p><strong>Mounted</strong></p><blockquote><p>el被vm.$el替代，并挂载到实例上去后调用该钩子</p></blockquote><p><strong>beforeUpdate</strong></p><blockquote><p>在虚拟dom重新渲染和打补丁之前调用</p></blockquote><p><strong>Updated</strong></p><blockquote><p>dom渲染之后调用的钩子,当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p></blockquote><p><strong>beforeDestroy</strong></p><blockquote><p>实例销毁之前调用的函数</p></blockquote><p><strong>Destroyd</strong></p><blockquote><p>实例销毁之后调用的函数</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://segmentfault.com/a/1190000008570622" target="_blank" rel="noopener">文章1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡和去重</title>
      <link href="/2018/02/02/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/02/02/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这里简单介绍介绍一下数组几个常常会被问到的数组处理的解决方法</p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><ul><li><p>冒泡排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function mp(arr)&#123;</span><br><span class="line">  for(var i=0,len=arr.length;i&lt;len;i++)&#123;</span><br><span class="line">    for(var j=i+1;j&lt;len;j++)&#123;</span><br><span class="line">      if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">        var flag=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=flag;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>快速排序(二元法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function ey(arr)&#123;</span><br><span class="line">  if(arr.length==0)&#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125;</span><br><span class="line">  var midIndex=Math.floor((arr.length/2));</span><br><span class="line">  var midVal=arr.splice(midIndex,1);</span><br><span class="line">  var left=[];</span><br><span class="line">  var right=[];</span><br><span class="line">  for(var i=0,len=arr.length;i&lt;len;i++)&#123;</span><br><span class="line">    if(arr[i]&lt;midVal)&#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ey(left).concat(midVal,ey(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sort方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function so(a,b)&#123;</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br><span class="line">function px(arr,fn)&#123;</span><br><span class="line"> return arr.sort(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><ul><li><p>indexOf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">  var newArr=[arr[0]];</span><br><span class="line">  for(var i=0,len=arr.length;i&lt;len;i++)&#123;</span><br><span class="line">    if(newArr.indexOf(arr[i])==-1)&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">  var newArr=[];</span><br><span class="line">  for(var i=0,len=arr.length;i&lt;len;i++)&#123;</span><br><span class="line">    var flag=false;</span><br><span class="line">    for(var j=0;j&lt;len;j++)&#123;</span><br><span class="line">      if(arr[i]==arr[j])&#123;</span><br><span class="line">        flag=true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树是一种非线性数据存储结构，一般用来存储有层级关系的数据，比如文件系统的文件和有序列表，二叉树的特征是子节点不能超过2个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">//这个是后面需要创建的每个节点的构造函数，每个节点有对应的数据</span><br><span class="line">function Node(data,left,right)&#123;</span><br><span class="line">  this.data=data;</span><br><span class="line">  this.left=left;</span><br><span class="line">  this.right=right;</span><br><span class="line">  this.show=show;</span><br><span class="line">&#125;</span><br><span class="line">//这个是给节点返回数据的</span><br><span class="line">function show()&#123;</span><br><span class="line">  return this.data;</span><br><span class="line">&#125;</span><br><span class="line">//这个是实例化树结构的操作函数</span><br><span class="line">function BST()&#123;</span><br><span class="line">  this.root=null;</span><br><span class="line">  this.insert=insert;//插入函数操作</span><br><span class="line">  this.inOrder = inOrder;</span><br><span class="line">  this.getMin = getMin;</span><br><span class="line">  this.getMax = getMax;</span><br><span class="line">  this.find = find;</span><br><span class="line">  this.remove = remove;</span><br><span class="line">&#125;</span><br><span class="line">//分装插入函数的逻辑</span><br><span class="line">function insert(data)&#123;</span><br><span class="line">  var n=new Node(data,null,null);//先实例化出一个子节点，还没有被插入</span><br><span class="line">  if(this.root==null)&#123;</span><br><span class="line">    this.root=n;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    var current=this.root;</span><br><span class="line">    var parent;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">      parent=current;</span><br><span class="line">      if(data&lt;current.data)&#123;</span><br><span class="line">        current=current.left;</span><br><span class="line">        if(current==null)&#123;</span><br><span class="line">          parent.left=n;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        current=current.right;</span><br><span class="line">        if(current==null)&#123;</span><br><span class="line">          parent.right=n;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//中序遍历</span><br><span class="line">function midOrder(node)&#123;</span><br><span class="line">  if(!(node==null))&#123;</span><br><span class="line">    midOrder(node.left);</span><br><span class="line">    console.log(node.show());</span><br><span class="line">    midOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//先序遍历</span><br><span class="line">fucnction preOrder(node)&#123;</span><br><span class="line">   if(!(node==null))&#123;</span><br><span class="line">    console.log(node.show());</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//后序遍历</span><br><span class="line">function afterOrder(node)&#123;</span><br><span class="line">  if(!(node==null))&#123;</span><br><span class="line">    afterOrder(node.left);</span><br><span class="line">    afterOrder(node.right);</span><br><span class="line">    console.log(node.show());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询最小值</span><br><span class="line">function getMin()&#123;</span><br><span class="line">  var current=this.root;</span><br><span class="line">  while(!(current.left==null))&#123;</span><br><span class="line">    current=current.left;</span><br><span class="line">  &#125;</span><br><span class="line">  return current.data;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树上查找最大值</span><br><span class="line">function getMax() &#123;</span><br><span class="line">    var current = this.root;</span><br><span class="line">    while(!(current.right == null)) &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return current.data;</span><br><span class="line">&#125;</span><br><span class="line">// 查找给定值</span><br><span class="line">function find(data) &#123;</span><br><span class="line">    var current = this.root;</span><br><span class="line">    while(current != null) &#123;</span><br><span class="line">        if(current.data == data) &#123;</span><br><span class="line">            return current;</span><br><span class="line">        &#125;else if(data &lt; current.data) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">function remove(data) &#123;</span><br><span class="line">    root = removeNode(this.root,data);</span><br><span class="line">&#125;</span><br><span class="line">function getSmallest(node) &#123;</span><br><span class="line">   if (node.left == null) &#123;</span><br><span class="line">      return node;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      return getSmallest(node.left);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">function removeNode(node,data) &#123;</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if(data == node.data) &#123;</span><br><span class="line">        // 没有子节点的节点</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; </span><br><span class="line">        // 没有左子节点的节点</span><br><span class="line">        if(node.left == null) &#123;</span><br><span class="line">            return node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有右子节点的节点</span><br><span class="line">        if(node.right == null) &#123;</span><br><span class="line">            return node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 有2个子节点的节点</span><br><span class="line">        var tempNode = getSmallest(node.right);</span><br><span class="line">        node.data = tempNode.data;</span><br><span class="line">        node.right = removeNode(node.right,tempNode.data);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;else if(data &lt; node.data) &#123;</span><br><span class="line">        node.left = removeNode(node.left,data);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        node.right = removeNode(node.right,data);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代码初始化</span><br><span class="line">代码初始化如下：</span><br><span class="line">var nums = new BST();</span><br><span class="line">nums.insert(23);</span><br><span class="line">nums.insert(45);</span><br><span class="line">nums.insert(16);</span><br><span class="line">nums.insert(37);</span><br><span class="line">nums.insert(3);</span><br><span class="line">nums.insert(99);</span><br><span class="line">nums.insert(22);</span><br><span class="line">midOrder(nums.root);//3,16,22,23,37,49,45</span><br><span class="line">preOrder(nums.root);//23,16,3,,22,45,37,99</span><br><span class="line">after(nums.root);//3,22,16,37,99,45</span><br><span class="line">var min = nums.getMin();</span><br><span class="line">console.log(min);//3</span><br><span class="line">var max = nums.getMax();</span><br><span class="line">console.log(max);//99</span><br><span class="line">var value = nums.find(&quot;45&quot;);</span><br><span class="line">console.log(value);//</span><br><span class="line">nums.remove(23);</span><br></pre></td></tr></table></figure></p><blockquote><p>参考文章：<a href="https://www.cnblogs.com/tugenhua0707/p/4361051.html" target="_blank" rel="noopener">https://www.cnblogs.com/tugenhua0707/p/4361051.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 数组去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/2018/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/2018/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>浏览器缓存对于复杂程度比较大的应用来说是非常重要的<a id="more"></a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>减少带宽</li><li>减少服务器压力(不用每次都发送请求到服务器)</li><li>提升性能(加载本地缓存资源要比加载服务器的速度要快)<h3 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h3></li><li>强缓存<blockquote><p>用户发送的请求，直接从客户端缓存获取，不发送请求到服务器，不与服务器发生交互行为</p></blockquote></li><li>协商缓存<blockquote><p>用户发送请求到服务器，让服务器确认是否要从浏览器缓存中读取缓存</p></blockquote></li></ul><p><strong>共同点：</strong>客户端获得的数据最后都是从客户端缓存中获得。<br><strong>两者的区别：</strong>从名字就可以看出，强缓存不与服务器交互，而协商缓存则需要与服务器交互。</p><h3 id="一张图解析缓存的机制"><a href="#一张图解析缓存的机制" class="headerlink" title="一张图解析缓存的机制"></a>一张图解析缓存的机制</h3><p><img src="https://raw.githubusercontent.com/chenjiaobin/chenjiaobin.github.io/Source/themes/raytaylorism/source/css/images/20180130105118.png" alt="浏览器缓存"></p><h3 id="文字解答"><a href="#文字解答" class="headerlink" title="文字解答"></a>文字解答</h3><ul><li><p>expires<br>Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。<br>可以看到过期时间被设定为了：Thu, 28 Sep 2017 06:38:37 GMT<br>存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。</p></li><li><p>Cache-Control<br>Http1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。<br>简单介绍下Cache-Control的属性设置。<br>1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires<br>2) s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存，<br>而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires.<br>3) public：响应会被缓存，并且在多用户间共享。默认是public。<br>4) private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。<br>5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。<br>6）no-store: 绝对禁止缓存。<br>7）must-revalidate: 如果页面过期，则去服务器进行获取。</p><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3></li><li>100 表示http发送了http header后，服务器返回的一个状态值</li><li>200 表示请求正常</li><li>201 表示服务器收到请求，并且在服务器创建了资源</li><li>202 服务器收到请求，但是尚未处理</li><li>301 请求被移动到新的地址(比如：域名换了，那我们直接在nginx服务器上设置当访问老域名的时候重定向到新的域名return 301 new url;还有就是我们输入地址默认是使用http协议，我们可以在服务器上设置重定向到https协议)</li><li>302 资源展示转移（比如：短连接跳转到长连接）</li><li>303 临时性重定向，但总是使用get请求新的uri</li><li>304 资源没有被修改过</li><li>400 必要的参数丢失或者参数格式不正确</li><li>401 请求需要授权</li><li>403 请求成功，但是服务器拒绝提供服务</li><li>404 请求资源不存在，可能是url输入错误</li><li>500 请求服务器错误（可能是代码异常但是没有被成功捕获，被tomcat服务器捕获了），当服务彻底挂掉了，连返回都没有的时候，那么就会出现502</li><li>502 bad gateway 网关错误（可能是因为nginx收到请求，但是请求没有打过去，可能是因为业务服务挂掉了，或者是打过去的端口号错了）</li><li>503 服务器过载，这种就是高并发会出现的问题，同时有很多人在同一时间访问</li><li>504 网关超时(服务器请求太久，比如php规定的时间为30s只要超过这个时间就会返回504)<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li><li>过程执行完后，如果判定为未过期，则使用客户端缓存，那么就是属于“强缓存”</li><li>否则就是协商缓存，跟服务器协商是否使用缓存，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified和Etag字段，浏览器将在 header中加入If-modified-since(对应Last-modified表示请求的资源上一次的修改时间)和If-none-match(对应Etag,资源的内容表示符，一般用md5或者一段hash值)，协商缓存中最后服务器会将Cache-control\expire\last-modified\date\etag</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强缓存 </tag>
            
            <tag> 协商缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js执行机制</title>
      <link href="/2018/01/29/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/29/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>js执行是单线程的，也就是同一时间只能干一件事。但是HTML5后面又提出了一个web workers的概念，它允许js创建多线程，但是子线程是被主线程控制的，子线程不能操作dom元素，这个新标准并没有改变js单线程的本质。<a id="more"></a><br>所有任务可以分为同步任务和异步任务</p><ul><li>同步任务：在主线程上执行的任务，只有当上一个任务结束后才能执行下一个任务</li><li>异步任务：这里的任务没有进入主线程，而是在任务队列里面，只有当<strong>任务队列</strong>通知主线程的时候，这个异步任务才会进入主线程进行执行<h3 id="异步执行的运行机制"><a href="#异步执行的运行机制" class="headerlink" title="异步执行的运行机制"></a>异步执行的运行机制</h3></li><li>所有同步任务在主线程里面执行，形成一个<strong>执行栈</strong></li><li>主线程之外还有一个<strong>任务队列(task queue)</strong>,只要异步任务有了运行结构，就在“任务队列里面放置一个事件”</li><li>一旦“执行栈”所有同步任务执行结束后，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3>主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event LOOP(事件循环),event loop有两种，一种是在浏览器上下文的，一种是在work上下文的，浏览器上下文至少有一个event loop,像一个iframe，浏览器窗口都会有一个event loop,而对于work上下文的则比较简单，work进程管理着一个event loop<h3 id="Event-Loop的运行流程"><a href="#Event-Loop的运行流程" class="headerlink" title="Event Loop的运行流程"></a>Event Loop的运行流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.在最老的任务队列中取出最老的任务，如果没有任务就直接跳入microtask队列中</span><br><span class="line">2.将event loop的当前任务设置成最老的任务</span><br><span class="line">3.执行当前任务队列中最老的任务</span><br><span class="line">4.将当前运行任务设置成null</span><br><span class="line">5.在队列中将刚刚执行的那个任务移除</span><br><span class="line">6.执行microtask队列算法</span><br><span class="line">7.更新渲染</span><br><span class="line">8.如果是一个work event loop，但是没有任务，并且workerglobalscrope对象的closing flag为true的，就销毁event loop并终止这些步骤，并执行web worker的run worker算法</span><br><span class="line">9.返回到第一步，这就形成了一个event loop事件循环的机制</span><br></pre></td></tr></table></figure></li></ul><p>由上面的步骤可以看出，没执行一次任务都会去清空microtask队列，也就是第6步</p><h3 id="Microtask与Macrotask的区别"><a href="#Microtask与Macrotask的区别" class="headerlink" title="Microtask与Macrotask的区别"></a>Microtask与Macrotask的区别</h3><p>一次event loop(事件循环)就会取一个macrotask执行，但是会将一个microtask队列清空，也就是如，microtask队列如果太长的话就会导致阻塞下一个macrotask的执行，在异步中，虽然js是异步非阻塞的，但是却是使用<strong>同步</strong>的方式来执行micortask。另外从字面上来说，macrotask属于大型的任务，microtask属于小任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">macrotask: setTimeout\setInterval\setImmediate\I/O</span><br><span class="line">microtask: promist/process.nextTick/</span><br></pre></td></tr></table></figure></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;first&quot;);</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(&quot;second&quot;);</span><br><span class="line">&#125;,0)</span><br><span class="line">Promist.resolve().then(()=&gt;&#123;</span><br><span class="line">console.log(&quot;third&quot;)</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">console.log(&quot;four&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;five&quot;)</span><br><span class="line">//最后chrome输出的顺序是first five second third four</span><br></pre></td></tr></table></figure><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p>js并不是完完全全的一行一行往下执行的，当我们遇到Promise和setTimeout这一类的代码的时候就会发现，因为js里面包含了同步和异步的程序执行方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    let p = new Promise((resovle, reject)=&gt;&#123;</span><br><span class="line">         console.log(7);</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">           console.log(5);</span><br><span class="line">           resovle(6); </span><br><span class="line">        &#125;,0)</span><br><span class="line">        resovle(1);</span><br><span class="line">    &#125;); </span><br><span class="line">    resovle(2);</span><br><span class="line">    p.then((arg)=&gt;&#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">first().then((arg)=&gt;&#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure></p><ul><li>第一轮事件循环<br>先执行宏任务，主script ，new Promise立即执行，输出【3】，执行p这个new Promise 操作，输出【7】，发现setTimeout，将回调放入下一轮任务队列（Event Queue），p的then，姑且叫做then1，放入微任务队列，发现first的then，叫then2，放入微任务队列。执行console.log(4)，输出【4】,宏任务执行结束。<br>再执行微任务，执行then1，输出【1】，执行then2，输出【2】。到此为止，第一轮事件循环结束。开始执行第二轮。</li><li>第二轮事件循环<br>先执行宏任务里面的，也就是setTimeout的回调，输出【5】。resovle不会生效，因为p这个Promise的状态一旦改变就不会在改变了。 所以最终的输出顺序是3、7、4、1、2、5。<blockquote><p>概念：宏任务和微任务</p></blockquote><h3 id="repaint-重绘-和reflow-回流"><a href="#repaint-重绘-和reflow-回流" class="headerlink" title="repaint(重绘)和reflow(回流)"></a>repaint(重绘)和reflow(回流)</h3></li></ul><ul><li>reflow:这个几乎是无法避免的，即某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素包括兄弟元素，这个时候浏览器要重新渲染这个子元素相关联的所有元素的过程称为<strong>回流</strong></li><li>repaint:这个就是改变子元素不影响到父元素的另一种叫法，叫<strong>重绘</strong><br>注意：repaint速度明显快于reflow</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.cnblogs.com/MasterYao/p/5563725.html" target="_blank" rel="noopener">文章1</a></li><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">文章2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Event Loop </tag>
            
            <tag> task queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2018/01/29/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2018/01/29/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>防抖和节流都是优化高频率执行js代码的一种手段。<a id="more"></a><br>在一定时间内，代码执行的次数不一定要非常多。达到一定频率就足够了。因为跑得越多，带来的效果也是一样。倒不如，把js代码的执行次数控制在合理的范围。既能节省浏览器CPU资源，又能让页面浏览更加顺畅，不会因为js的执行而发生卡顿。这就是函数节流和函数防抖要做的事。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>函数节流：确保函数在一定时间内至多执行一次。（比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。）</li><li>函数防抖：确保函数在特定时间内不再被调用后执行（注册时当用户输入邮箱的时候可以进行延迟验证）<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3>简单点讲就是函数是在特定时间内最多执行一次，如果在特定时间内再次调用函数那么就会被禁止掉，直接return出来，不会去执行函数里面的主要代码，所以一般我们会在函数里面加上一个标志区分上一次时候执行完毕（函数在上一次执行结束后才能再次执行）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var flag=true</span><br><span class="line">function text()&#123;</span><br><span class="line">  if(!flag)&#123;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  var flag=false;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    flag=true;</span><br><span class="line">  &#125;,300)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到<strong>函数节流</strong>主要是通过定义一个标志的变量</p><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>简单点讲就是第二次执行函数会把第一次函数的执行结束掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">  var time=null;</span><br><span class="line">  clearTimeout(time);</span><br><span class="line">  time=setTimeout(function()&#123;</span><br><span class="line">    console.log(&quot;防抖函数&quot;);</span><br><span class="line">  &#125;,300)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 函数防抖的实现</span><br><span class="line"> * @param  &#123;Function&#125; func   要实现函数节流的原函数</span><br><span class="line"> * @param  &#123;Number&#125;   delay  结束的延迟时间</span><br><span class="line"> * @return &#123;Function&#125;        添加节流功能的函数</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function debounce (func, delay) &#123;</span><br><span class="line">  let debounceIdentify = 0</span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    debounceIdentify &amp;&amp; clearTimeout(debounceIdentify)</span><br><span class="line">    debounceIdentify = setTimeout(() =&gt; &#123;</span><br><span class="line">      debounceIdentify = 0</span><br><span class="line">      func.apply(this, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。<br>比如，我们一般提交表单在收到数据之前会使用一个loading来表示数据正在加载，但是当数据不是很大的时候loading就会一闪而过，那么我们就可以通过设置一个延迟函数来解决这个问题，在接受到数据后就要清除这个定时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let identify=setTimeout(showBackModle,500);</span><br><span class="line">fetch(url).then(res=&gt;&#123;</span><br><span class="line">  //do something</span><br><span class="line">  clearTimeout(identify)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.topfe.cn/javascript/395.html" target="_blank" rel="noopener">文章1</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节流 </tag>
            
            <tag> 防抖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2018/01/25/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/01/25/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>跨域的兴起主要是为了解决解决安全性的问题，浏览器采用同源策略的方法，对js进行限制，防止了恶意用户获取非法数据，同时也防止了大部分的XSS共计（用户向网站注入js脚本）。<a id="more"></a></p><h3 id="浏览器两种同源策略出现跨域问题"><a href="#浏览器两种同源策略出现跨域问题" class="headerlink" title="浏览器两种同源策略出现跨域问题"></a>浏览器两种同源策略出现跨域问题</h3><ul><li>DOM同源策略：禁止对不同源的Dom进行操作，主要包括iframe和canvas等，不同源的iframe禁止数据交互，含有不同源数据的canvas会受到污染而无法进行操作</li><li>xmlHttpRequest同源策略：简单点讲就是禁止不同源的ajax请求，主要用来防止CSRF的攻击<h3 id="跨域请求的方式"><a href="#跨域请求的方式" class="headerlink" title="跨域请求的方式"></a>跨域请求的方式</h3></li><li>jsonp(这种方式主要是利用了script/img/iframe的src可以请求不同源的数据文件的特点)</li><li>CORS(这种是官方提供的方法，在很多浏览器上也是兼容的，IE10以上)<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3>也叫“跨域资源共享”，这个标准定义了跨域访问资源时浏览器和服务器要怎么通信，通俗讲就是跨域访问的时候浏览器的header会附加一些头信息与服务器进行沟通。其实CORS背后的思想就是通过自定义Http头部让浏览器和服务器进行沟通。跨域主要分为<strong>简单请求</strong>和<strong>非简单请求</strong></li></ul><ol><li><strong>简单请求</strong><br>请求方式是get/post/head<br>头信息是一下字段之一：Accept/Accept-Language/Content-Language/Content-type(不包括application/json)<br>当浏览器识别到这个请求是简单请求的时候，就会在头信息附加上一个origin字段，这个头信息会把这次请求的（协议+域名+端口）传递给服务器，服务器会检查这个请求的来源。要是服务器同意了这个来源呢，在正常回复浏览器的同时，就也附加上几条字段作为回礼：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin // 这条写着服务同意的来源，或者一个代表所有来源的 “*”</span><br><span class="line">Access-Control-Allow-Credentials // 这条写着浏览器可以发Cookie过来了总的来说得到服务器的认可了，这样浏览器就能正常收到回应了</span><br></pre></td></tr></table></figure></li></ol><p>要是不同意，服务器就正常返回数据，啥也不附加，浏览器见不到Access-Control-Allow-Origin会不高兴的，然后就不给你返回的数据了，再然后就是报错</p><ol start="2"><li><strong>非简单请求</strong><br>这种请求的主要方式是为put/delete，头信息可能为application/json,但是这个过程浏览器与服务器之间的交互会多了一次预检请求，以options的请求方式发送请求，头信息包括origin字段，同时还有Access-Control-Request-Header(这条是浏览器跨域请求的时候要额外附加的信息)和Access-Control-Request-Methods(这条是告诉服务器等会的跨域请求是啥方式)<br>服务器收到预检请求提交过来的信息后，也会严格一点，不仅检查来源，还检查请求方式和头信息字段。要是服务器同意了，就在正常的HTTP回应中附加上Access-Control-Allow-Origin字段，也同样写着服务同意的来源。这就代表这拿到服务器的认可了，毕竟是经历过严格检查的，接下来的每次跨域请求都会正常进行。要是不同意，服务器也是啥都不附加地正常回应，这个时候浏览器看不见Access-Control-Allow-Origin可是会生气的，连跨域请求都懒得发，直接报错。<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3>JSONP 是 JSON with padding(填充式 JSON 或参数式 JSON )的简写，是应用 JSON 的一种新方法。JSONP 的原理非常简单，为了克服跨域问题，利用没有跨域限制的 script 标签加载预设的 callback 将内容传递给 JavaScript。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">      alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> var script = document.createElement(&quot;script&quot;);</span><br><span class="line"> script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;</span><br><span class="line"> document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//jQuery实现跨域</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function doSomething(jsonData) &#123;</span><br><span class="line">        alert(&apos;doSomething &apos; + jsonData.status);</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &quot;get&quot;,</span><br><span class="line">        url: &apos;http://localhost:8002/jsonp&apos;,</span><br><span class="line">        dataType: &quot;jsonp&quot;,</span><br><span class="line">        jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span><br><span class="line">        jsonpCallback: &quot;doSomething&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span><br><span class="line">        success: function (json) &#123;</span><br><span class="line">            alert(json.status);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">            alert(&apos;fail&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//a.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function onLoad() &#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">        var win = iframe.contentWindow;</span><br><span class="line">        win.postMessage(&quot;我来自页面a&quot;, &quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">//b.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onmessage = function (e) &#123;</span><br><span class="line">        e = e || event;</span><br><span class="line">        alert(e.data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/entry/587c35608d6d810058cdc41e" target="_blank" rel="noopener">文章1</a></li><li><a href="https://juejin.im/entry/573a6ea31ea493006444e09c" target="_blank" rel="noopener">文章2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CORS </tag>
            
            <tag> JSONP </tag>
            
            <tag> postMessage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2018/01/25/%E7%BC%93%E5%AD%98/"/>
      <url>/2018/01/25/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互。<a id="more"></a></p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>如果不在浏览器设置cookie过期时间，那么cookie会被缓存在内存中，生命周期会跟随浏览器会话结束而结束，这种属于会话cookie,如果设置了cookie的过期时间，那么这个cookie就会被保存在硬盘中，直到过期时间到期后cookie才会失效。cookie是服务器返回给客户端特殊的信息，客户端以文本的形式存放，每次请求都会带上，大小一般在4kb左右，所以如果cookie存放的过大的话就会消耗性能</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>当服务器收到请求后需要创建session，那么回想检查客户端的请求中是否包含sessionid,如果有的话了么服务器端就会获取这个id下的session返回给客户端，否则服务器端就会创建一个session,并且会将这个sessionid的值返回给客户端。session存放大小没有限制。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</p><h3 id="localstorage-sessionstorage"><a href="#localstorage-sessionstorage" class="headerlink" title="localstorage/sessionstorage"></a>localstorage/sessionstorage</h3><p>这两种数据的缓存方式是HTML5新添加的webstorage，数据存放大小为5MB，他们不跟服务器进行交互通信，不需要持续的将数据发送给服务器，这也是客户了cookie的一些限制<br>localstorage属于永久性缓存，除非我们手动清除这个缓存值<br>sessionstorage属于会话缓存，只要浏览器的会话结束缓存也会被清空<br>只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理<br>应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</p><h3 id="缓存之间的区别"><a href="#缓存之间的区别" class="headerlink" title="缓存之间的区别"></a>缓存之间的区别</h3><ul><li>cookie的应用场景和优缺点<br>场景</li></ul><ol><li>存放用户上次登录的时间等信息，以便下次自动登录</li><li>保存上次查看的页面</li><li>浏览计数<br>缺点</li><li>数据存放空间小，只有4kb左右</li><li>浪费带宽，因为每次请求都需要附带cookie信息到服务器</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li></ol><ul><li>session<br>场景</li></ul><ol><li>缓存购物车信息</li><li>缓存用户的登录信息</li><li>将数据放到session中，是用户在不同页面上可以使用</li><li>防止用户非法登录<br>缺点：</li><li>如果session过多的时候会造成服务器压力过大</li><li>依赖于cookie，如果禁用了cookie的话那么session的路径就得重写，这样会导致不安全</li><li>创建session随意性比较大，如果session过多的时候就会导致不好维护</li></ol><ul><li>webstorage的优点</li></ul><ol><li>存储空间大：cookie才4KB,websotrage有5MB</li><li>安全性高：webstorage不会通过http-header发送到服务器，所以也不用担心信息被截获，但是还是存在伪造的可能性</li><li>节省网络流量：websotrage不像cookie每次发送请求都得带上cookide，webstorage获取缓存的信息可以直接在客户端通过特性的方法获取,所以节省了服务器端和客户端之间的交互<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li></ol><ul><li>保持状态：cookie保存在浏览器端，session保存在服务器端</li><li>cookie始终在同源的http中携带而且每次请求都会在服务器端和客户端之间来回传递</li><li>cookie/localstorage/sessionstorage都是存放在浏览器端的，session这是存放在服务器端的<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><a href="https://www.cnblogs.com/cencenyue/p/7604651.html" target="_blank" rel="noopener">参考文章</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
            <tag> localStorage </tag>
            
            <tag> sessionStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布局</title>
      <link href="/2018/01/24/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/"/>
      <url>/2018/01/24/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>最常用的布局是定位布局、流布局、浮动布局，flex布局和grid是后面新奇的，flex相对来说兼容性比较好，主要是解决一些一维上的问题，而grid兼容性还不是很好，它主要就是解决二维上的问题<a id="more"></a></p><h3 id="BFC-IFC-GFC-FFC"><a href="#BFC-IFC-GFC-FFC" class="headerlink" title="BFC/IFC/GFC/FFC"></a>BFC/IFC/GFC/FFC</h3><p>CSS2.1只有BFC/IFC,CSS3.0加了GFC/FFC(flex和grid)</p><h3 id="BFC定义"><a href="#BFC定义" class="headerlink" title="BFC定义"></a>BFC定义</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。<br><strong>BFC规则</strong></p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">//如果这两个元素同时设置margin，那么会出现重叠的现象，因为他们这两个元素处于同一个BFC里面，如果要解决问题可以将他们分别放到不同的BFC中</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p></li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算<br><strong>哪些元素会生成BFC</strong></li><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ul><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC就是属于”内联格式化上下文”，跟BFC差不多</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定位 </tag>
            
            <tag> 流 </tag>
            
            <tag> 浮动 </tag>
            
            <tag> flex </tag>
            
            <tag> grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链和比特币</title>
      <link href="/2018/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2018/01/22/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>区块链是一个去中心化处理分布式账本的数据库<a id="more"></a></p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>先来考虑一个中心化集中式处理的过程。你要在某宝上买一部手机，交易流程是：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家，那么这中间就多了一个第三方。在这个过程中，虽然你是在和卖家交易，但是这笔交易还牵扯到了除了你和卖家的第三方，即支付宝，你和卖家的交易都是围绕支付宝展开。因此，如果支付宝系统出了问题便会造成这笔交易的失败。并且虽然你只是简单的买了一个手机，但是你和卖家都要向第三方提供多余的信息。因此考虑极端情况，如果支付宝跑路了或者是拿了钱不却不承认你的交易或者是支付宝所在的城市因为开G20把所有人都赶走了，那么你就悲剧了。那么去中心化的的这一特性就显得很重要了，这种交易方式相当于点对点的交易，不用经过第三方。也可以避免透露出没有必要的个人隐私</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在去中心化以后，整个系统中没有了权威的中心化代理，信息的可信度和准确性便会面临问题。</p><h3 id="简单的例子解释区块链"><a href="#简单的例子解释区块链" class="headerlink" title="简单的例子解释区块链"></a>简单的例子解释区块链</h3><p>我们先来建立一个去中心化的系统，为了方便理解，我们来看一个简单的去中心化借贷模型：如果A借了B 100块钱，这个时候，A在人群中大喊“我是A，我借给了B 100块钱！”，B也在人群中大喊“我是B，A借给了我100块钱！”，此时路人甲乙丙丁都听到了这些消息，因此所有人都在心中默默记下了“A借给了B100块钱”。你看，这个时候一个去中心化的系统就建立起来了，这个系统中不需要银行，也不需要借贷协议和收据，严格来说，甚至不需要人与人长久的信任关系（比如B突然又改口说“我不欠A钱！”，这个时候人民群众就会站出来说“不对，我的小本本上记录了你某天借了A100块钱！”）。</p><h3 id="比特币挖矿的概念"><a href="#比特币挖矿的概念" class="headerlink" title="比特币挖矿的概念"></a>比特币挖矿的概念</h3><p>比如我在系统中自己创造出了“爱国币”这个概念，后面这个概念也被他人认可，那么就我拥有“爱国币”这个成为了现实真实存在的东西，但是这个系统中一共就只有10个“爱国币”，于是有人动了坏心思，他在人群中高呼“我有10个爱国币！”怎么办？大家是直接在本本上记下他有10个么，这样不是人人都可以伪造了么？为了解决这个问题，我就需要将我创造的这个“爱国币打上标记”,我的才是货真价实的，这样以后在每一笔交易的时候，我在高喊“我给了某某1个爱国币！”的时候，会附加上额外的一句话：“这1个爱国币的来源是记为001的那条记录，我的这句话标记为002！”。我们再抽象一点，某人喊话的内容的格式就变成了：“这句话编号xxx，上一句话的编号是yyy，我给了某某1个爱国币！”，这样就解决了伪造的问题。为了激励大家帮我传话和记账，我决定给第一个听到我喊话并且记录在小本本上的人一些奖励：第一个听到我喊话并记录下来的人，你就凭空得到了1个爱国币，这个爱国币是整个系统对你幸苦记账的报酬，而你记录了这句话之后，要马上告诉其它人你已经记录好了，让别人放弃继续记录这句话，并给你自己的记录编号让别人有据可查，然后你再把我的话加上你的记录编号一起喊出来，供下一个人记账。当这个规则定下以后，这个系统中一定会出现一批人，他们开始竖着耳朵监听周围发出的声音，以抢占第一个记账的权利。对的，你脑海中是不是又浮现出了“比特币挖矿”的字眼？</p><p>作者：汪乐-LaiW3n<br>链接：<a href="https://www.zhihu.com/question/37290469/answer/107612456" target="_blank" rel="noopener">https://www.zhihu.com/question/37290469/answer/107612456</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>art-template</title>
      <link href="/2018/01/21/atr-template%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
      <url>/2018/01/21/atr-template%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>art-template的诞生方便了前端对于页面数据的渲染，可以直接通过特定的语法来实现模板数据的渲染，不用通过字符串拼接的方式来进行渲染页面<a id="more"></a>js模版引擎的诞生使得前端的数据和页面分离出来了，它采用预编译方式让性能有了质的飞跃，并且充分利用 javascript 引擎特性，使得其性能无论在前端还是后端都有极其出色的表现。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>渲染性能极强</li><li>调试友好：语法、运行时错误日志精确到模板所在行；支持在模板文件上打断点（Webpack Loader）</li><li>支持 Express、Koa、Webpack</li><li>支持模板继承与子模板<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></li><li>安装tmodjs <code>npm install -g tmodjs</code>,这个是为了生成template.js用的，将art-template的语法处理的数据解析成浏览器能认识的数据</li><li>在项目中新建一个template文件夹</li><li><p>在template文件夹里面新建一个模板文件，比如header.html,然后再这里面写art-template的逻辑语法和数据渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&#123;&#123;menu1&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&#123;&#123;menu2&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&#123;&#123;menu3&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录里面新建一个index.html,这个文件是一个demo，为了将我们的模版文件header.html渲染上去</p></li><li>在index.html引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;./template/build/template.js&quot;&gt;&lt;/script&gt;</code>这个是我们后面生成的一个文件</li><li><p>在index.html里面写ajax请求，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&apos;http://192.168.1.109:3000/jdapi&apos;,</span><br><span class="line">type:&apos;get&apos;,</span><br><span class="line">cache:false,</span><br><span class="line">dataType:&apos;jsonp&apos;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">var jdModule=template(&apos;header&apos;,data);//这里面这个header的名字就是我们刚才新建的模板文件的名字，data就是我们请求来的json数据</span><br><span class="line">        $(&quot;.box&quot;).html(jdModule);//jdModule是返回的模板，数据也已经渲染好了</span><br><span class="line">&#125;,</span><br><span class="line">error:function(xhr,status,errorThrown)&#123;</span><br><span class="line">console.log(xhr.status);</span><br><span class="line">console.log(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>最后通过cmd进入template文件夹<code>cd template</code>,执行<code>tmod .</code>,这个时候在template里面会新建出一个build文件夹和package.json文件，build里面有一个template.js文件，这个文件就是art-template将我们的模板文件解析压缩成这个文件</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li><p>普通取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line">&#123;&#123;data.key&#125;&#125;</span><br><span class="line">&#123;&#123;data[&apos;key&apos;]&#125;&#125;</span><br><span class="line">&#123;&#123;a ? b : c&#125;&#125;</span><br><span class="line">&#123;&#123;a || b&#125;&#125;</span><br><span class="line">&#123;&#123;a + b&#125;&#125;</span><br><span class="line">&#123;&#123;set temp = data.sub.content&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>逻辑判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;if index == 0 &#125;&#125; </span><br><span class="line">index = 0</span><br><span class="line">&#123;&#123;else if index &gt; 0 &amp;&amp; index &lt; 5&#125;&#125;</span><br><span class="line">index 大于 0 并且 index 小于 5</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">index = &#123;&#123;index&#125;&#125;</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//persionList是一个数组，index是循环的下标，person是每次循环的item</span><br><span class="line">&#123;&#123;each personList as person index&#125;&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123;index&#125;&#125; : &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入字模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;include &apos;./grammarSub&apos;&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>模板继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &#123;&#123;extend &apos;./layout.art&apos;&#125;&#125;</span><br><span class="line">&#123;&#123;block &apos;head&apos;&#125;&#125; ... &#123;&#123;/block&#125;&#125;</span><br><span class="line">//lay.art</span><br><span class="line">&lt;!--layout.art--&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123;block &apos;title&apos;&#125;&#125;My Site&#123;&#123;/block&#125;&#125;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;block &apos;head&apos;&#125;&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;</span><br><span class="line">    &#123;&#123;/block&#125;&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123;block &apos;content&apos;&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;!--index.art--&gt;</span><br><span class="line">&#123;&#123;extend &apos;./layout.art&apos;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &apos;title&apos;&#125;&#125;&#123;&#123;title&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &apos;head&apos;&#125;&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;custom.css&quot;&gt;</span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &apos;content&apos;&#125;&#125;</span><br><span class="line">&lt;p&gt;This is just an awesome page.&lt;/p&gt;</span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br><span class="line">//渲染 index.art 后，将自动应用布局骨架。</span><br></pre></td></tr></table></figure></li></ul><p>上面这种语法是标准的语法，art-template的原始语法处理逻辑能力更强,法标准语法则可以让模板易读写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (user) &#123; %&gt;</span><br><span class="line">  &lt;h2&gt;&lt;%= user.id %&gt;&lt;/h2&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%= value %&gt;</span><br><span class="line">&lt;%= data.key %&gt;</span><br><span class="line">&lt;%= data[&apos;key&apos;] %&gt;</span><br><span class="line">&lt;%= a ? b : c %&gt;</span><br><span class="line">&lt;%= a || b %&gt;</span><br><span class="line">&lt;%= a + b %&gt;</span><br><span class="line">&lt;% var temp = data.sub.content; %&gt;</span><br></pre></td></tr></table></figure></p><h3 id="art-template结合其他框架使用"><a href="#art-template结合其他框架使用" class="headerlink" title="art-template结合其他框架使用"></a>art-template结合其他框架使用</h3><p>首先先安装组件<br><code>npm install art-template --save</code></p><h3 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h3><p><a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank" rel="noopener">art-template中文文档</a><br><a href="http://www.imooc.com/article/20263" target="_blank" rel="noopener">art-template基础</a><br><a href="http://www.imooc.com/article/20293" target="_blank" rel="noopener">art-template语法</a><br><a href="http://www.imooc.com/article/20334" target="_blank" rel="noopener">art-template实战</a><br><a href="https://github.com/chenjiaobin/art-template" target="_blank" rel="noopener">art-template完整例子</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> art-template </tag>
            
            <tag> 前端模版引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2018/01/17/Flex%E5%B8%83%E5%B1%80/"/>
      <url>/2018/01/17/Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>在网页布局没有进入 CSS 的时代，排版几乎是通过 table 元素实现的，在 table 的单元格里可以方便的使用 align、valign 来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：标准文档流、浮动布局和定位布局。<a id="more"></a>这几种布局能够解决常见的布局问题，然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。</p><h3 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h3><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content<h3 id="Flex容器属性详解"><a href="#Flex容器属性详解" class="headerlink" title="Flex容器属性详解"></a>Flex容器属性详解</h3></li></ul><ol><li><p>大容器设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  display:-webkit-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-direction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//项目排列方向</span><br><span class="line">flex-direction:row|column|row-reverse|column-reverse;</span><br></pre></td></tr></table></figure></li><li><p>flex-wrap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置如果一条轴线排不下，如何换行</span><br><span class="line">flex-wrap:wrap|nowrap|wrap-reverse;</span><br></pre></td></tr></table></figure></li><li><p>flex-flow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这个是flex-direction和flex-wrap的结合</span><br><span class="line">flex-flow:&lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">flex-flow:row nowrap</span><br></pre></td></tr></table></figure></li><li><p>justify-content</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置主轴的对齐方式</span><br><span class="line">justify:flex-start|flex-end|center|space-around|space-between</span><br></pre></td></tr></table></figure></li><li><p>align-items</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置交叉轴的对齐方式</span><br><span class="line">align-items:flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></li><li><p>align-content</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//该属性设置多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</span><br><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h3><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self<h3 id="Flex项目属性详解"><a href="#Flex项目属性详解" class="headerlink" title="Flex项目属性详解"></a>Flex项目属性详解</h3></li></ul><ol><li><p>order</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</span><br><span class="line">order:1;</span><br></pre></td></tr></table></figure></li><li><p>flex-grow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</span><br><span class="line">flex-grow:1</span><br></pre></td></tr></table></figure></li><li><p>flex-shrink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效</span><br><span class="line">flex-shrink:1</span><br></pre></td></tr></table></figure></li><li><p>flex-basis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span><br><span class="line">flex-basis: &lt;length&gt; | auto; //auto 是默认值</span><br></pre></td></tr></table></figure></li><li><p>flex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这个属性是flex-grow和flex-shrink和flex-basis的简写</span><br><span class="line">flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">//该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br></pre></td></tr></table></figure></li><li><p>align-self</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line"> align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li><p>圣杯布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//html代码</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">  &lt;header&gt;&lt;/header&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;main class=&quot;main&quot;&gt;&lt;/main&gt;</span><br><span class="line">    &lt;nav class=&quot;nav&quot;&gt;&lt;/nav&gt;</span><br><span class="line">    &lt;aside class=&quot;side&quot;&gt;&lt;/aside&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//css代码</span><br><span class="line">.box&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  display:-webkit-flex;</span><br><span class="line">  flex-flow:column row;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">  display:flex;</span><br><span class="line">  display:-webkit-flex;</span><br><span class="line">&#125;</span><br><span class="line">header,footer&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">&#125;</span><br><span class="line">.nav,.side&#123;</span><br><span class="line">  flex:0 0 12em;</span><br><span class="line">&#125;</span><br><span class="line">.nav&#123;</span><br><span class="line">  order:-1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>主栏的左侧或右侧，需要添加一个图片栏。(左边是图片，右边是文字)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Media&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.Media &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: flex-start;</span><br><span class="line">&#125;</span><br><span class="line">.Media-figure &#123;</span><br><span class="line">  margin-right: 1em;</span><br><span class="line">&#125;</span><br><span class="line">.Media-body &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>固定的底栏<br>情景：有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body class=&quot;Site&quot;&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">html,body &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.Site-content &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">文章1</a> | <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">文章2</a> | <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">文章3</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flex </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid布局</title>
      <link href="/2018/01/16/Grid%E5%B8%83%E5%B1%80/"/>
      <url>/2018/01/16/Grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>Grid是一款二维网格布局系统。CSS在处理网页布局方面一直做的不是很好。一开始我们用的是table（表格）布局，然后用float(浮动)，position（定位）和inline-block（行内块）布局，但是这些方法本质上是hack，遗漏了很多功能，例如垂直居中。后来出了flexbox(盒子布局)，解决了很多布局问题，但是它仅仅是一维布局，而不是复杂的二维布局，实际上它们（flexbox与grid）能很好的配合使用。Grid布局是第一个专门为解决布局问题而创建的CSS模块。<a id="more"></a></p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>Chrom–Firefox–opera–Android–Ios的高版本基本都能兼容，但是还是有部分低版本的浏览器不能识别愈语法，使用需要慎用</p><h3 id="Grid容器属性"><a href="#Grid容器属性" class="headerlink" title="Grid容器属性"></a>Grid容器属性</h3><ul><li>display:grid|inline-grid|subgrid</li><li>grid-template-columns</li><li>grid-template-rows</li><li>grid-row-gap</li><li>grid-column-gap</li><li>grid-gap</li><li>grid-template-areas(配合grid-area使用)</li><li>justify-items</li><li>align-items</li><li>justify-content</li><li>align-content</li><li>grid-auto-columns</li><li>grid-auto-rows</li><li>grid-auto-flow</li><li>grid<h3 id="Grid容器属性使用详解"><a href="#Grid容器属性使用详解" class="headerlink" title="Grid容器属性使用详解"></a>Grid容器属性使用详解</h3></li></ul><ol><li><p>display</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//display使用详解</span><br><span class="line">grid: 生成块级网格</span><br><span class="line">inline-grid: 生成行内网格</span><br><span class="line">subgrid: 如果网格容器本身是网格项（嵌套网格容器），此属性用来继承其父网格容器的列、行大小</span><br></pre></td></tr></table></figure></li><li><p>grid-template-columns和grid-template-rows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//grid-template-columns用来设置列的个数和列的宽度</span><br><span class="line">grid-template-columns:10px 10px;//表示两列每列的宽度为10px</span><br><span class="line">grid-template-columns:1fr 20px 2fr;//容器宽度先减掉20px然后再将剩余的宽度分成3分，第一个项目占1/3,第三个占2/3</span><br><span class="line">grid-template-columns:repeat(3 20px) 1fr;//repeat主要是用来写重复值用的，这里相当于grid-template-columns:20px 20px 20px 1fr;</span><br><span class="line">grid-template-columns:minmax(100px,300px) 200px;//这个minmax作用是设置项目的最小宽度为100px,最大值为300px,当然也可以是auto</span><br><span class="line">grid-template-columns:repeat(auto-fit,minmax(100px,1fr))//这个相当于设置了media-query，根据设备宽度调整项目排序，主要起作用的是auto-fit</span><br><span class="line">//grid-template-rows也是跟上面这个是一样的，只是变成行，即从上到下排列</span><br></pre></td></tr></table></figure></li><li><p>grid-row-gap和grid-column-gap和grid-gap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//grid-row-gap和grid-column-gap分别是设置行间距和列间距</span><br><span class="line">//grid-gap是其他两个的结合</span><br><span class="line">//第一个值是列间距，第二个是行间距</span><br><span class="line">grid-gap:10px 20px;</span><br></pre></td></tr></table></figure></li><li><p>grid-template-areas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//这个是通过别名来设置网格模版的,结合grid-area使用</span><br><span class="line">.contain&#123;</span><br><span class="line">  display:grid;</span><br><span class="line">  grid-template-areas:&quot;header header header header&quot;</span><br><span class="line">                      &quot;main main . sidebar&quot;</span><br><span class="line">                       &quot;footer footer footer footer&quot;;</span><br><span class="line">&#125;</span><br><span class="line">.item-a&#123;</span><br><span class="line">  grid-area:header;</span><br><span class="line">&#125;</span><br><span class="line">.item-b&#123;</span><br><span class="line">  grid-area:main;</span><br><span class="line">&#125;</span><br><span class="line">.item-c&#123;</span><br><span class="line">  grid-area:sidebar;</span><br><span class="line">&#125;</span><br><span class="line">.item-d&#123;</span><br><span class="line">  grid-area:footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>justify-items和align-items</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这个是设置列方向的对齐方式</span><br><span class="line">justify-items:start|end|center|stretch(填满)</span><br><span class="line">//这个是设置行方向的对齐方式</span><br><span class="line">align-items:start|end|center|stretch</span><br></pre></td></tr></table></figure></li><li><p>justify-content和align-content</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如果用像px非弹性单位定义的话，总网格区域大小有可能小于网格容器，这时候你可以设置网格的对齐方式，一般如果想不出现这种情况我们可以通过fr和百分比等方式来避免</span><br><span class="line">.container&#123;</span><br><span class="line">display:grid;</span><br><span class="line">justify-content:start|end|center|space-between|space-around|stretch|space-evenly(网格项间隙相等)</span><br><span class="line">&#125;</span><br><span class="line">//下面是行对齐，上面是列对齐</span><br><span class="line">.container&#123;</span><br><span class="line">display:grid;</span><br><span class="line">align-content:start|end|center|space-between|space-around|stretch|space-evenly(网格项间隙相等)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>grid-auto-columns和grid-auto-rows<br>自动生成隐式网格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//生成一个2x2的表格</span><br><span class="line">.container&#123;</span><br><span class="line">  display:grid;</span><br><span class="line">  grid-template-columns:60px 60px;</span><br><span class="line">  grid-template-rows:50px 50px;</span><br><span class="line">&#125;</span><br><span class="line">//item-a定义的表格位置是存在的</span><br><span class="line">.item-a&#123;</span><br><span class="line">  grid-column:1/2;</span><br><span class="line">  grid-row:2/3;</span><br><span class="line">&#125;</span><br><span class="line">//item-b定义的表格区域是不存在的</span><br><span class="line">.item-b&#123;</span><br><span class="line">  grid-column:5/6;//这个网格是不存在的，所以达不到我们的效果，那</span><br><span class="line">  grid-row:2/3;</span><br><span class="line">&#125;</span><br><span class="line">//解决方法：我们可以在.container容器里面添加grid-auto-column:60px;这样就会帮我们隐式创建出这个表格了</span><br></pre></td></tr></table></figure></li><li><p>grid-auto-flow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这个是用来试着网格项下排列方式的</span><br><span class="line">.cotainer&#123;</span><br><span class="line">  display:grid;</span><br><span class="line">  grid-auto-flow:row|column|dense(按先后顺序排列)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>grid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这个是其他几个容器属性的集合</span><br><span class="line">.cotainer&#123;</span><br><span class="line">  display:grid;</span><br><span class="line">  grid:none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [ / &lt;grid-auto-columns&gt;] ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>接着就是介绍一下项目属性了</p><h3 id="Grid项目属性"><a href="#Grid项目属性" class="headerlink" title="Grid项目属性"></a>Grid项目属性</h3><ul><li>grid-column-start</li><li>grid-column-end</li><li>grid-row-start</li><li>grid-row-end</li><li>grid-column</li><li>grid-row</li><li>grid-area</li><li>justify-self</li><li>align-self<h3 id="Grid项目属性详解"><a href="#Grid项目属性详解" class="headerlink" title="Grid项目属性详解"></a>Grid项目属性详解</h3></li></ul><ol><li><p>grid-column-start和grid-column-end和grid-row-start和grid-row-end和grid-column和grid-row</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//则几个都是以网格线来定位的</span><br><span class="line">.item-a&#123;</span><br><span class="line">  grid-column-start:1;</span><br><span class="line">  grid-column-end:2;</span><br><span class="line">  grid-row-start:1;</span><br><span class="line">  grid-row-end:2;</span><br><span class="line">&#125;</span><br><span class="line">//相当于</span><br><span class="line">.item-a&#123;</span><br><span class="line">  grid-column:1/2;</span><br><span class="line">  grid-row:1/2;</span><br><span class="line">&#125;</span><br><span class="line">//span引用</span><br><span class="line">.item-c&#123;</span><br><span class="line">  grid-column:1 / span 2; //合并1,2,3个网格</span><br><span class="line">  grid-row:1 / 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>grid-ara</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//可以定义区域的名字，结合grid-template-areas使用</span><br><span class="line">.item-a&#123;</span><br><span class="line">  grid-area:header;</span><br><span class="line">&#125;</span><br><span class="line">//也可以通过他获取一个区域</span><br><span class="line">// grid-area:&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; ;</span><br><span class="line">.item-b&#123;</span><br><span class="line">  grid-area:1/2/1/2 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>align-self和justify-self</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置网格项的对齐方式</span><br><span class="line">start: 网格区域左对齐。</span><br><span class="line">end: 网格区域右对齐。</span><br><span class="line">center: 网格区域居中。</span><br><span class="line">stretch: 网格区域填满</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a><a href="https://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">参考博文</a></h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局 </tag>
            
            <tag> Grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node和Express</title>
      <link href="/2018/01/09/express%E5%85%A5%E9%97%A8/"/>
      <url>/2018/01/09/express%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>###Express介绍<br>这是一款基于node.js的快速、开发、极简的开发开发框架,也算是目前比较流行的基于node.js的开发框架，可以快速搭建一个完整的网站。使用express之前需要在本机安装node.js环境<a id="more"></a>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建文件夹</span><br><span class="line">mkdir demo</span><br><span class="line">//进入文件夹</span><br><span class="line">cd demo </span><br><span class="line">//执行初始化，创建出package.json文件，这个过程需要填写一些参数 </span><br><span class="line">npm init </span><br><span class="line">//安装express依赖,直接安装在本项目需要添加save</span><br><span class="line">npm install express --save</span><br><span class="line">//全局安装express方式为</span><br><span class="line">npm install -g express</span><br><span class="line">//创建一个index.js文件,不一定是index.js，这要看你在init的时候填写的入口文件是什么</span><br><span class="line">在index.js里面写如下代码</span><br><span class="line">var express=require(&apos;express&apos;);</span><br><span class="line">var app=express();</span><br><span class="line">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class="line">res.send(&apos;chenjiaobin Hellow world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var server=app.listen(3300,function()&#123;</span><br><span class="line">var host=server.address().address;</span><br><span class="line">var port=server.address().port;</span><br><span class="line">console.log(&quot;example app listeneing at&quot;,host,port);</span><br><span class="line">&#125;)</span><br><span class="line">//最后执行打开服务</span><br><span class="line">node index.js</span><br><span class="line">//浏览器访问</span><br><span class="line">localhost:3300</span><br></pre></td></tr></table></figure><h3 id="express自动生成框架"><a href="#express自动生成框架" class="headerlink" title="express自动生成框架"></a>express自动生成框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//先全局安装一个express应用生成器</span><br><span class="line">npm install express-generator -g</span><br><span class="line">//创建demo文件夹</span><br><span class="line">mkdir demo</span><br><span class="line">//进入文件夹</span><br><span class="line">cd demo</span><br><span class="line">//生成开发框架</span><br><span class="line">express demoexpress</span><br><span class="line">//进入demoexpress文件夹</span><br><span class="line">cd demoexpress</span><br><span class="line">app.js //入口文件</span><br><span class="line">bin //配置文件夹</span><br><span class="line">public //静态资源文件夹</span><br><span class="line">routes //路由文件夹</span><br><span class="line">view //页面文件夹，页面格式为jade</span><br><span class="line">//安装依赖，就是将package.json现有的依赖安装</span><br><span class="line">npm install</span><br><span class="line">//开启服务</span><br><span class="line">npm start</span><br><span class="line">//可以修改标题，要进入/routes/index.js,里面有title可以更改</span><br><span class="line">//页面上访问,端口可以通过在bin/www这里面的这个www文件里面查看</span><br><span class="line">localhost:3000</span><br><span class="line">//但是这样的话，每次更改页面内容都得去重新启动服务npm start,那么我们可以通过 supervisor这个依赖来解决这个问题，它会实时监控每个文件的更改</span><br><span class="line">//安装这个依赖</span><br><span class="line">npm install -g supervisor</span><br><span class="line">//启动服务不需要npm start了，直接执行</span><br><span class="line">supervisor  ./bin/www</span><br></pre></td></tr></table></figure><p>简单的demo就做好了</p><h3 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h3><p>介绍：Mock.js是一款数据生成器，能使前端独立开发，不依赖后端，也可以编写单元测试<br>使用前就需要通过npm这个包管理器进行安装<br><code>npm install mockjs -g</code><br>对应的api可以通过该网站学习<a href="http://mockjs.com/0.1/" target="_blank" rel="noopener">mockjs</a>,这里面也有一个在线数据模版编辑器，能够在线将数据模板调试成功然后复制到我们自己的服务器生成我们的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果我们是使用简单的一个html文件来使用mockjs的话，那么我们直接引入mockjs文件，然后调用里面的方法就行了</span><br><span class="line">&lt;!-- （必选）加载 Mock --&gt;</span><br><span class="line">&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">//调用方法</span><br><span class="line">var data = Mock.mock(&#123;</span><br><span class="line">    &apos;list|1-10&apos;: [&#123;</span><br><span class="line">        &apos;id|+1&apos;: 1</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4))</span><br><span class="line">    .appendTo(&apos;body&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如果是node.js搭建的环境，那么我们需要通过下载依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//引入依赖包</span><br><span class="line">npm install mockjs -g</span><br><span class="line">/使用</span><br><span class="line">var Mock = require(&apos;mockjs&apos;);</span><br><span class="line">var data = Mock.mock(&#123;</span><br><span class="line">    &apos;list|1-10&apos;: [&#123;</span><br><span class="line">        &apos;id|+1&apos;: 1</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line">console.log(JSON.stringify(data, null, 4))</span><br></pre></td></tr></table></figure></p><h3 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h3><p><a href="http://mockjs.com/0.1" target="_blank" rel="noopener">mockjs文档</a><br><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener">express文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git版本工具</title>
      <link href="/2017/12/14/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/12/14/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>git作为当今比较流行的版本管理工具，对于我们每个开发人员来说都是必须懂的一个科目<a id="more"></a>git之所以令人费解，主要是因为它比svn等传统的版本管理工具多引入了一个<em>暂存区Stage</em> 的概念</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><ol><li>工作区</li><li>暂存区(Stage)</li><li>本地仓库</li><li>远程仓库<br>他们每次进入一个区成功后会产生一种状态，在加上最初始的一种状态，总共有5中状态<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3></li><li>未修改（origin）</li><li>已修改（modified）</li><li>已暂存（staged）–git add .</li><li>已提交（commited）–git commit -m “”</li><li>已推送（pushed）<h3 id="查看更改的内容git-diff"><a href="#查看更改的内容git-diff" class="headerlink" title="查看更改的内容git diff"></a>查看更改的内容git diff</h3></li></ol><ul><li>当我们修改的文件还没提交到暂存区的时候（还没执行git add .）,我们可以通过<code>git diff 文件名</code>查看文件前后添加了那些内容，这是查看工作区和暂存区的差异</li><li>当我们修改的文件已经提交到暂存区的时候（还没执行git commit .）,我们需要通过<code>git diff --cashed</code>查看文件前后添加了那些内容，这个是查看暂存区和本地仓库的差异</li><li>当我们将修改的文件提交到本地服务器的时候（还没执行git push）,我们需要通过<code>git diff master origin/master</code>查看差异，这是本地仓库和远程仓库之间的比较<h3 id="git的4个阶段的撤销更改"><a href="#git的4个阶段的撤销更改" class="headerlink" title="git的4个阶段的撤销更改"></a>git的4个阶段的撤销更改</h3></li><li>在工作区修改了东西还没有执行<code>git add .</code>,这时候我们的修改还没有提交到暂存区，可以通过<code>git checkout .</code>或<code>git reset --hard</code>进行撤销操作</li><li>如果已经执行了<code>git add .</code>,未执行<code>git commit</code>,那么这时候可以通过<code>git reset</code>或<code>git checkout .</code>或<code>git reset --hard</code>进行撤销操作</li><li>如果已经执行了<code>git commit</code>,未执行<code>git push</code>,那么需要执行<code>git reset --hard origin/master</code>,意思就是本地仓库被污染了，那么我就从远程仓库把老的代码取回来</li><li>如果执行<code>git push</code>,那么需要通过执行<code>git reset --hard HEAD^</code>,在强制push到远程仓库就好了<code>git push -f</code><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3>有时候提交代码的commit的信息丢失，需要找到commit的SHA，然后创建一个指定他的分支，因为.git/log文件会每次都记录提交的信息，我们可以通过<code>git relog</code>来查看提交的日志信息，如果想要更详细的日志信息，那可以通过执行<code>git log -g</code>,确定好丢失好的commit后，就可以在这个commit上创建一个新分支将其回复过来，<code>git branch newBranch ab1afef</code>后面这一串字符是日志记录中的hash值，我们只要取得前面几个字符就可以了，如果过在.git/log找不到丢失的commit信息后，那可以通过执行<code>git fsck --full</code>该命令会检查仓库的完整性，会显示所有未被其他对象引用的所有对象<code>git fsck --full</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理</title>
      <link href="/2017/12/13/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2017/12/13/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>项目管理是对保证整个业务流程规范化以及适应市场需求，同时也能对整个项目的进度进行相应的调控，对出现的问题及时的进行沟通解决，有效的提高整个项目的可维护性。<a id="more"></a></p><h3 id="一、项目启动流程规范"><a href="#一、项目启动流程规范" class="headerlink" title="一、项目启动流程规范"></a>一、项目启动流程规范</h3><p><strong>项目的可行性分析</strong></p><ol><li>政策可行性–eg. youtube、google在某种程度上不符合中国的国情和政策</li><li>市场可行性</li><li>技术可行性</li><li>经济可行性–eg. SAE(新浪的公有云，也算是国内首个公有云，因为维护超出了预算，不敌百度云)、BAE(百度云)、阿里云<br><strong>项目文档的编写</strong><ol><li>作用：有效避免项目可能出现的风险，使得每个过程都有据可依，使整个项目规范化<br><strong>需求管理</strong></li></ol></li><li>获取需求：由使用方提供需求文档，双方进行开会分析，填写《需求调研表》</li><li>需求确认：双方进行需求确认，签合同</li><li>需求跟踪：</li><li>需求变更控制：要对需求进行等级划分，实现功能是属于一等级，对于样式等不影响功能使用的属于二等级，对于可能实现的，主要是针对客户个人喜好的属于三等奖<br>总结：所有的开发都是以业务为导向的，作为产品经理对客户的提问主要问的不是要用什么样的架构，需要用到什么样的数据库等技术，而是要了解产品的目标是什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离</title>
      <link href="/2017/11/29/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
      <url>/2017/11/29/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>对于大部分应用，已经不需要从后端读取HTML页面或者模板，前端完全可以根据数据自行渲染页面/模板，这样，前后台交互就可以简化为数据的增删改查。利用AJAX技术，实现页面局部刷新，促使了前后台分离的可能性。<a id="more"></a></p><h3 id="产品文档"><a href="#产品文档" class="headerlink" title="产品文档"></a>产品文档</h3><p>产品经理会先设计好整个产品的业务模块和流程，并给出产品文档，包括UI交互，流程图，模块划分等等。这个时候，产品，前端，后端，测试需要一起评审文档，可能需要多次评审才能确定设计方案。</p><h3 id="前端提供接口定义"><a href="#前端提供接口定义" class="headerlink" title="前端提供接口定义"></a>前端提供接口定义</h3><p>第二个阶段是前后台同时开发时期。后端同学在设计数据库和表结构的时候，前端同学应该熟悉交互文档和整个业务在表现层上的流程，并且根据页面的展现方式，给出合理或者期望的数据模型（一般是JSON数据结构） 。<br>比如，需要哪些接口？接口API是只读的还是可修改的？接口入参是什么？接口出参是什么？……这些问题，以往都是由后端同学考虑并定义的。但是，实际上，前端同学是最熟悉交互操作的，前端同学期望的API也是最符合页面需求的，当然，如果某个接口涉及到其他业务模块时，它的复杂性可能就无法在页面上体现出来。然而，无论如何，前端同学是应该，也能够在接口定义上提供合理，富有建设性意见的方案。<br>因此，第二阶段，前端需要给后端同学提供一份接口定义清单。</p><h3 id="后端给出接口文档，并通过review"><a href="#后端给出接口文档，并通过review" class="headerlink" title="后端给出接口文档，并通过review"></a>后端给出接口文档，并通过review</h3><p>阶段二前端同学提供的接口设计清单，毕竟只是建议，真正的接口还需要后端定义和实现。所以，第三阶段，后端需要提供正式的API文档，并且，前端同学参加review，确保所有的API（入参，出参，和HTTP请求方法）都被双方认可</p><h3 id="前后端同步开发"><a href="#前后端同步开发" class="headerlink" title="前后端同步开发"></a>前后端同步开发</h3><p>API文档确定后，前后台就能够同时开发了。这时，又可能分为两种情况。</p><p>(1) 后端已经定义好接口并且发布，但是，返回值都为假数据，不支持修改操作。前端同学利用已发布的API进行测试。<br>(2) 后端没有发布任何接口，前端同学自行mock数据（利用本地json文件，或者在线的一些mock工具，比如easy mock等模拟数据），然后边写页面边测试。</p><h3 id="联调阶段"><a href="#联调阶段" class="headerlink" title="联调阶段"></a>联调阶段</h3><p>当后端业务代码已经完成，前端页面和数据交互部分完成，前后端就可以进行联调了。这个阶段，是磨合期，肯定会出现很多问题，也需要双方协商去解决。</p><p>当后台接口变更时，必须同步更新API文档，并第一时间通知前端同学，保证前台接口调用也同步更新。</p><p>同时，测试人员可以介入，针对接口进行单元测试。注意，这时只是针对接口的黑盒测试，不要涉及任何UI操作。</p><h3 id="冒烟测试和其他安全性测试"><a href="#冒烟测试和其他安全性测试" class="headerlink" title="冒烟测试和其他安全性测试"></a>冒烟测试和其他安全性测试</h3><p>当联调阶段完成后，也就是开发人员（前端和后端）认为已经没有bug的情况下，项目再交由测试人员进行冒烟测试。同时，有需要的话，同时安排安全性测试。<br>几轮测试，几轮bug fixing之后，项目就可以上线了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以看到，前后端分离开发模式可以让分工更明确，提高生产效率，加速项目开发和迭代，也能够让API文档化，便于后期维护。<br>原文作者：娜姐聊前端<br>链接：<a href="http://www.jianshu.com/p/21775989ec46" target="_blank" rel="noopener">http://www.jianshu.com/p/21775989ec46</a><br>來源：简书</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2017/11/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
      <url>/2017/11/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>一张面向对象的图清晰的解释了各函数以及对象之间的继承关系<a id="more"></a><br><img src="https://raw.githubusercontent.com/chenjiaobin/chenjiaobin.github.io/Source/themes/raytaylorism/source/css/images/oop-4.jpg" alt="面向对象原型继承图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> Function </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas</title>
      <link href="/2017/11/12/canvas%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2017/11/12/canvas%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>canvas这个画图标签是HTML5新增的一个标签，非常实用，可以根据需要绘制出各种各样的图形。</p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul><li>内容实际上是绘制在屏幕上；</li><li>画布，即Canvas，只是规定了绘制内容时的规则；</li><li>内容的位置由坐标决定，而坐标是相对于画布而言的<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p><em>步骤：</em></p><ul><li>获得标签(获得canvas标签)</li><li>获得上下文(getContext)</li><li>填充颜色的选择(fillStyle)</li><li>边框颜色的选择(strokeStyle)</li><li>开始画图形(fillRect或strokeRect)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var canvas=document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var context=canvas.getContext(&apos;2d&apos;);</span><br><span class="line">context.fillStyle=&apos;#000&apos;;</span><br><span class="line">context.strokeStyle=&apos;orange&apos;;</span><br><span class="line">context.lineWidth=&apos;5px&apos;;</span><br><span class="line">context.fillRect(0,0,200,100);</span><br><span class="line">context.strokeRect(20,20,50,30);</span><br><span class="line">context.strokeRect(30,30,50,30);//可以重复绘制</span><br></pre></td></tr></table></figure></li></ul><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p><em>步骤：</em></p><ul><li>获得标签</li><li>获得上下文</li><li>开始画图声明(beginPath)</li><li>绘制图片参数设置(arc(x,y,radius,beginAngle,endAngle,isTrueOrFalse))</li><li>结束绘制声明(clossePath)</li><li>设置圆形绘制的填充色或者边框颜色</li><li>开始绘制(fill()或者stoke())<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var canvas1=document.getElementById(&apos;canvas1&apos;);</span><br><span class="line">context1=canvas1.getContext(&apos;2d&apos;);</span><br><span class="line">context1.fillStyle=&apos;#333&apos;;</span><br><span class="line">context1.fillRect(0,0,200,100);//填充画布颜色</span><br><span class="line">context1.beginPath();//开始绘制圆形</span><br><span class="line">   //参数分别表示横坐标、纵坐标、半径、起始角度、结束角度、是否顺时针方向绘制</span><br><span class="line">context1.arc(10,10,10,0,Math.PI*2,true);//设置参数</span><br><span class="line">context1.closePath();</span><br><span class="line">   // context1.fillStyle=&apos;rgba(255,0,0,0.25)&apos;;</span><br><span class="line">   // context1.fill();</span><br><span class="line">context1.strokeStyle=&apos;#000&apos;;</span><br><span class="line">context1.stroke();</span><br></pre></td></tr></table></figure></li></ul><p><em>注：</em><br>如果不加beginPath和closePath的话，如果绘制是放在循环绘制里面的话，后面绘制图形会把前面的都继续重叠绘制上去，如果只绘制一次的话（也就是没有循环那么就没有什么区别）</p><h3 id="绘制字体"><a href="#绘制字体" class="headerlink" title="绘制字体"></a>绘制字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var canvas=document.getElementById(&apos;canvas&apos;);</span><br><span class="line">    context=canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    context.fillStyle=&apos;#000&apos;;</span><br><span class="line">    context.fillRect(0,0,300,200);</span><br><span class="line">    context.fillStyle=&apos;#fff&apos;;</span><br><span class="line">    context.strokeStyle=&apos;#fff&apos;;</span><br><span class="line">    context.font=&quot;bold 40px &apos;微软雅黑&apos;,&apos;宋体&apos;&quot;;//有三个参数font-weight/font-size/font-family</span><br><span class="line">    context.textBaseline=&apos;hangling&apos;;//垂直方向的对其方式，默认值是alphabetic/hanging/top/bottom/middle</span><br><span class="line">    context.textAlign=&apos;left&apos;;//竖直方向的对齐方式，start,left,right,end,right</span><br><span class="line">    context.fillText(&apos;陈焦滨&amp;kevin&apos;,0,0,300);//四个参数：绘制的文字/横坐标/纵坐标/宽度最大值</span><br><span class="line">    context.strokeText(&apos;陈焦滨&amp;kevin&apos;,0,0,300);</span><br></pre></td></tr></table></figure><h3 id="canvas保存文件"><a href="#canvas保存文件" class="headerlink" title="canvas保存文件"></a>canvas保存文件</h3><p>canvas API使用toDataURL方法吧绘画的状态输出到一个data URL中然后重新装载，然后我们就可以吧重新的文件直接保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var canvas=document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var context=canvas.getContext(&apos;2d&apos;);</span><br><span class="line">context.fillstyle=&apos;#000&apos;;</span><br><span class="line">window.location=canvas.toDataURL(&apos;image/jpeg&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get和post</title>
      <link href="/2017/11/07/get%E5%92%8Cpost/"/>
      <url>/2017/11/07/get%E5%92%8Cpost/</url>
      
        <content type="html"><![CDATA[<p>GET和POST的真正区别有哪些，当然浅层的区别大家都知道啦，但是但我们在面试的时候被问到的时候回答大家都知道的那就太没意思了，那么我就带大家来认识一下真正的深层次的区别。<a id="more"></a></p><h3 id="GET和POST的区别（浅层次）"><a href="#GET和POST的区别（浅层次）" class="headerlink" title="GET和POST的区别（浅层次）"></a>GET和POST的区别（浅层次）</h3><ul><li>GET传递数据是以url方式传递，而POST传递则是把参数放在request body（请求主体）进行发送</li><li>GET请求回退是无害的，而POST请求需要再一次提交请求</li><li>GET请求数据会被主动cache,而post不会，除非注定设置</li><li>GET只能支持url编码，而post没有限制</li><li>GET只接受ASCII,而POST没有限制</li><li>GET传递的参数是有限制的（一般在2kb左右），而post没有限制<br>但是，这只是他们两公婆之间浅层次的区别，要想自己逼格高一点，那么我们就要进一步了解他较为深层次的区别<h3 id="GET和POST的区别（深层次）"><a href="#GET和POST的区别（深层次）" class="headerlink" title="GET和POST的区别（深层次）"></a>GET和POST的区别（深层次）</h3>HTTP是基于TCP/IP的关于输入如何在万维网进行数据通信的协议，简单点讲HTTP就是交通规则，TCP/IP就是运输车<br>而GET和POST方法是HTTP上传递数据的方法之二，还有PUT，DELETE等，所以GET和POST的底层也是TCP/IP,也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。<br>当然，运输公司进行装货和卸货都是有成本的，所以不能无限制的在url上添加参数，对于GET请求在request body发送部分数据，有部分服务器是不接受的，也就不会帮你读出数据。<br>他们之间还有一个<em>更大</em>的区别，那就是GET产生一个TCP数据包，而POST产生两个TCP数据包，为什么呢？<br>GET请求的时候会把head和data一并发送给服务器，服务器响应200;而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。从中我们也认识到get发送请求的速度还是比较快的。<br>当然如果在网络比较好的情况下其实发送一次和发送两次没什么区别。<br>此文结束<del>~</del>~</li></ul><p>参考网址：<a href="https://juejin.im/post/59fc04ecf265da4317697f26?utm_source=gold_browser_extension" target="_blank" rel="noopener">地址</a><br>作者：陈焦滨&amp;kevin</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> get </tag>
            
            <tag> post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承之浅拷贝和深拷贝</title>
      <link href="/2017/10/28/%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/10/28/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>js是面向对象的弱类型的语言，对于js来说也是一个非常大的特性之一，其实继承主要的实现方式也是通过原型链的继承来继承父类的属性和方法的，也可以通过拷贝来复制一份属于自己的属性和方法。接下来就让我们说说继承的主要的几种方式。<a id="more"></a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝就是直接将父类的属性和方法通过for..in来循环复制到子类，那么子类就拥有了父类的所有方法。<br><em>缺点：</em>如果父类中有子对象或数组的时候，那么就会出行问题，需要通过递归来解决，这也是深拷贝到来的意义了，详细看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//浅拷贝</span><br><span class="line">var parent=&#123;</span><br><span class="line">  name:&apos;chen&apos;,</span><br><span class="line">  age:20,</span><br><span class="line">  where:&#123;born:pn,study:sz&#125;</span><br><span class="line">  arr:[1,2,4]</span><br><span class="line">&#125;</span><br><span class="line">var child=&#123;&#125;</span><br><span class="line">//以下是主要的实现方法</span><br><span class="line">function extend(parent,child)&#123;</span><br><span class="line">  var child=child||&#123;&#125;; //如果child是undefind的情况下，那么将child设置为空对象</span><br><span class="line">  for(var prop in parent)&#123;</span><br><span class="line">    child[prop]=parent[prop];  //在子对象里面开始添加属性和方法</span><br><span class="line">  &#125;</span><br><span class="line">  return child;</span><br><span class="line">&#125;</span><br><span class="line">var obj=new extend(parent,child)</span><br></pre></td></tr></table></figure></p><p><em>注：</em>这里出现的问题是,当执行<code>obj.name</code>可以获取到chen,这是正确的，但是当执行<code>obj.where.born=china</code>或<code>obj.arr[0]=88</code>的时候，那么父类的born和arr也会被修改，因为在for..in里面复制给子类的是一个应用而已，所以子类和父类引用的是同一个对象和数组。那么就需要用深拷贝的方式来解决了。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝相比于浅拷贝就是，深拷贝会将父类的子对象或数组通过用递归的方式来复制到子对象里面去。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//深拷贝</span><br><span class="line">var parent=&#123;</span><br><span class="line">  name:&apos;chen&apos;,</span><br><span class="line">  age:20,</span><br><span class="line">  where:&#123;born:pn,study:sz&#125;</span><br><span class="line">  arr:[1,2,4]</span><br><span class="line">&#125;</span><br><span class="line">var child=&#123;&#125;</span><br><span class="line">//以下是主要的实现方法</span><br><span class="line">function extendDeep(parent,child)&#123;</span><br><span class="line">  var child=child||&#123;&#125;; //如果child是undefind的情况下，那么将child设置为空对象</span><br><span class="line">  for(var prop in parent)&#123;</span><br><span class="line">    if(typeof parent[prop]===&apos;object&apos;)&#123; //因为数组和对象都属于对象，所以只要检测到时object那么肯定是引用类型的值</span><br><span class="line">      child[prop]=(Object.prototype.toString.call(parent[prop])==&apos;[object Array]&apos;)?[]:&#123;&#125;;</span><br><span class="line">      entendDeep(parent[prop],child[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">    child[prop]=parent[prop];  //在子对象里面开始添加属性和方法</span><br><span class="line">  &#125;</span><br><span class="line">  return child;</span><br><span class="line">&#125;</span><br><span class="line">var obj=new extend(parent,child)</span><br></pre></td></tr></table></figure></p><p>这种拷贝的方式完美解决了浅拷贝的问题</p><h3 id="函数继承"><a href="#函数继承" class="headerlink" title="函数继承"></a>函数继承</h3><p>函数继承可以通过call或apply来实现继承父类的属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">  this.name=&apos;chen&apos;;</span><br><span class="line">  this.age=&#123;now:12&#125;;</span><br><span class="line">&#125;</span><br><span class="line">function child(parent)&#123;</span><br><span class="line">   parent.call(this); //相当于parent.parent()接着就可以调用里面的name和age了</span><br><span class="line">   this.lang=&apos;english&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var obj=new child();</span><br></pre></td></tr></table></figure></p><h3 id="create实现继承"><a href="#create实现继承" class="headerlink" title="create实现继承"></a>create实现继承</h3><p>通过Object.create可以将对象的所有属性和方法继承给子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var parent=&#123;name:&apos;chen&apos;&#125;</span><br><span class="line">function child(p)&#123;</span><br><span class="line"> function f()&#123;&#125;;</span><br><span class="line"> f.prototype=p;</span><br><span class="line">f.prototype.constructor=f;</span><br><span class="line"> var ins=new f();</span><br><span class="line"> return ins;</span><br><span class="line"> &#125;</span><br><span class="line"> //上面的代码相当于</span><br><span class="line"> var parent=&#123;name:&apos;chen&apos;&#125;</span><br><span class="line">  function child(p)&#123;</span><br><span class="line">   var ins=Object.create(p)</span><br><span class="line">   return ins;</span><br><span class="line">   &#125;</span><br><span class="line">  //不过Object.create在低级浏览器是不能使用的，ie&gt;9</span><br></pre></td></tr></table></figure></p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>就是最普通的通过原型链来实现子类继承父类,继承的主要过程就是创建父类+创建子类+继承的实现方式</p><ul><li>第一种是直接将子类的child.prototype=parent.prototype,但是在这里有个问题就是子类自己的东西会暴露给父类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;&#125;</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">child.prototype=parent.prototype</span><br><span class="line">var obj=new child()</span><br><span class="line">//这样的话子类就能访问到父类prototype里面的属性和方法了</span><br><span class="line">//但是如果我们给子类child的原型prototype添加一个属性或方法child.prototype.xx=&apos;xxx&apos;，并且实例父类var g=new parent(),访问`g.xx`返回的结果是xxx,这样的话就是子类的东西暴露了给父类，这样是不行的</span><br></pre></td></tr></table></figure></li></ul><p>所以不能通过这种方式来实现继承</p><ul><li>第二种能够解决第一种方法出现的问题，但是又有新的问题就是会创建出一个多余的对象，并且会将父对象的不在原型上的属性和方法也同时复制到新创建的对象上。对象的作用主要是用来做桥接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;)</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">child.prototype=new parent();//这里创建的这个对象会将parent里面不在prototype上面的属性和方法复制到这个对象上面，这样如果parent的数据很大的情况下就会占用内存，造成性能方面上的问题</span><br><span class="line">var obj=new child();</span><br></pre></td></tr></table></figure></li></ul><p>那么就需要另外一种新的方式来解决这个问题</p><ul><li>第三种方式就是通过创建出一个新的函数，并且将子类的prototype等于新创建的函数的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;&#125;</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">funcion F()&#123;&#125;</span><br><span class="line">F.prototype=parent.prototype</span><br><span class="line">var f=new F();</span><br><span class="line">child.protype=f;</span><br><span class="line">var obj=new child();</span><br></pre></td></tr></table></figure></li></ul><p>这种方式是前面两种方式的结合体，借助了第一种方式<code>F.prototype=parent.prototype</code>来建立关系，借助了第二种方式创建桥接的方式来建立关系，所以这种方式解决了前面出现的问题</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个引用类型（变量）在不同状态下的多种类型。多态用途在面向对象的开发的时候，需要一个方法不变，但是他的参数是需要变化的，就可以使用多态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function DuoTai()&#123;</span><br><span class="line">var dom=document.getElementById(&apos;box&apos;);</span><br><span class="line"> if(arguments.length==0)&#123;</span><br><span class="line">    return dom.style.fontSize;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">    dom.style.fontSize=arguments[0]+&apos;px&apos;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解释：当我传递参数的时候，那么我就可以自行字体大小设置，如果没有传递参数的时候直接返回字体大小</span><br></pre></td></tr></table></figure></p><p><strong>重写</strong><br>重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载，这也是重载和重写的区别，上面那个DuoTai的函数就是重载的例子，同样的方法，但是参数可能不一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;&#125;</span><br><span class="line">parent.prototype.run=function()&#123;</span><br><span class="line">console.log(&apos;parent runing&apos;);</span><br><span class="line">&#125;</span><br><span class="line">child.prototype=Object.create(parent.prototype);</span><br><span class="line">child.prototype.constructor=child;</span><br><span class="line">child.super=parent.prototype; //这个方法是为了在子类中如果有与父类同名的方法或属性的时候仍然可以使用父类的属性和方法而不会被覆盖</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">child.prototype.run=function()&#123;</span><br><span class="line">console.log(&apos;child runing&apos;);</span><br><span class="line">child.super.run();//这个是调用父类parent中的run方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅拷贝 </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js三大特性五大原则</title>
      <link href="/2017/10/27/js%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2017/10/27/js%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>面向对象的概念：这是一种软件开发的一种方式，并不是只要在类中有体现出面向对象的三大特性就是面向对象编程了，还需要满足面向对象中的五大原则.<a id="more"></a></p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><ul><li>封装</li><li>继承</li><li>多态<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3>封装就是将散乱的东西整合成一个集体，可以拥有私有变量或方法和共有的变量或方法，这样就保护了内部变量不被篡改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Fn(name)&#123;</span><br><span class="line">  function a()&#123;</span><br><span class="line">    console.log(test.name);</span><br><span class="line">  &#125;</span><br><span class="line">  var test=&#123;</span><br><span class="line">    name:&apos;chenjiaobin&apos;,</span><br><span class="line">    this.fn=function()&#123;</span><br><span class="line">      a();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承就是儿子继承父亲的东西，父亲开放的东西我都能调用，继承有实现继承和接口继承两种，接口继承只承认方法签名，是指使用属性和方法的名称。但是子类必须提供实现的能力，而实现继承就是直接使用基类的方法和属性而无需而外编码的能力。由于函数没有签名，所以ECMAScript无法实现接口继承，而实现继承主要是依靠原型链来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;&#125;</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">function F()&#123;&#125;</span><br><span class="line">F.prototype=parent.prototype;</span><br><span class="line">child.prototype=new F();</span><br><span class="line">var obj=new child()</span><br></pre></td></tr></table></figure></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//同样的函数，但是传递参数的不同会有不同的表现显示也就是执行不同的算法</span><br><span class="line">function duotai()&#123;</span><br><span class="line">  var total=0;</span><br><span class="line">  if(arguments.length===0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    for(var i=0,ilen=arguments.length;i&lt;ilen;i++)&#123;</span><br><span class="line">      total+=arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h2><ul><li>单一职责原则</li><li>开放封闭原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。<br> 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！</p><h3 id="开发封闭原则"><a href="#开发封闭原则" class="headerlink" title="开发封闭原则"></a>开发封闭原则</h3><p>指对源码封闭，对功能扩展开发，比如在项目开发过程中有一个新的需求，那么我们就需要对新的需求做功能的扩展，在不影响原有代码的情况下实现功能</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>指子类可以替换父类在任何地方出现，这样做的好处就是，在根据新要求扩展父类接口的新子类的时候而不影响当前客户端的使用！</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>传统的结构化编程中父模块需要袭来低级的模块，用这个原则就是来逆转这种做法，让高层模块不依低层模块<br>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>原则的意思是：使用多个专门的接口比使用单个接口要好的多！<br>这个我有体会，在我实际编程中，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notification</title>
      <link href="/2017/10/23/%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5/"/>
      <url>/2017/10/23/%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>桌面通知可以方便我们实时的获取消息通知，就算我们关闭关闭浏览器也没什么事。<a id="more"></a><br>实现代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Notification.requestPermission().then(function(permission)&#123;</span><br><span class="line">  if(permission===&apos;granted&apos;)&#123;</span><br><span class="line">    var n=new Notification(&apos;更新提醒&apos;,&#123;</span><br><span class="line">      body:&apos;这是更新的主题内容&apos;,   //通知主题内容</span><br><span class="line">      tag:&apos;chen&apos;,   //每个通知都有特定的标签</span><br><span class="line">      icon:&apos;http://www.****.jpg&apos;, //通知的图片</span><br><span class="line">      requireInteraction:true   //通知保持有效不自动关闭</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;else if(permission===&apos;denied&apos;)&#123;</span><br><span class="line">    console.log(&apos;用户拒绝推送消息&apos;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(&apos;不知道用户的&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><em>注：</em></p><ul><li>granted表示允许</li><li>denied表示拒绝</li><li>default表示默认</li></ul><p>参考网站：<a href="https://juejin.im/post/59ed37f5f265da431e15eaac?utm_source=gold_browser_extension" target="_blank" rel="noopener">地址一</a><br>本文作者：陈焦滨&amp;kevin</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js设计模式</title>
      <link href="/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/10/17/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>js的设计模式增强我们代码结构的强度，可维护性更好，可复用性也更强。<a id="more"></a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式就是保证一个类只有一个实例，实现的方法是先判断实例时候存在，如果存在那么就直接返回实例，否则创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//例子1</span><br><span class="line">//创建xiaowan和xiaomin，xiaowan想通过门铃呼叫xiaomin,那么就要先判断门门铃时候存在吗，不存在就创建，存在就直接按门铃</span><br><span class="line">var xiaomin=(function()&#123;</span><br><span class="line">  var xiaominjia=func(msg)&#123;</span><br><span class="line">    this.melling=msg;</span><br><span class="line">  &#125;</span><br><span class="line">  var men;</span><br><span class="line">  var info=&#123;</span><br><span class="line">    sendMes:function()&#123;</span><br><span class="line">      if(!men)&#123;</span><br><span class="line">        men=new xiaominjia();</span><br><span class="line">      &#125;</span><br><span class="line">      return men;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return info;</span><br><span class="line">&#125;)()</span><br><span class="line">var xiaowan=&#123;</span><br><span class="line">  callXiaomin:function(msg)&#123;</span><br><span class="line">    var a=xiaomin.sendMes(msg);</span><br><span class="line">    console.log(a.melling);</span><br><span class="line">    a=null;//垃圾回收机制</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例子2（实际项目）</span><br><span class="line">//一个页面有很多点击事件，而且每个点击事件可能会需要用到上一个点击事件的数据等，那么我们可以将点击事件封装成一个独立的对象</span><br><span class="line"> var top=&#123;</span><br><span class="line">  init:function()&#123;</span><br><span class="line">    this.render();</span><br><span class="line">    this.bind();</span><br><span class="line">  &#125;,</span><br><span class="line">  a:4,</span><br><span class="line">  //获取点击事件的元素</span><br><span class="line"> render:function()&#123;</span><br><span class="line">  that=this;</span><br><span class="line">  that.btn=$(&quot;#a&quot;);</span><br><span class="line"> &#125;,</span><br><span class="line"> //绑定点击事件</span><br><span class="line"> bind:function()&#123;</span><br><span class="line">  that=this;</span><br><span class="line">  that.btn.onclick=function()&#123;</span><br><span class="line">    that.test();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> //点击触发的事件</span><br><span class="line"> test:function()&#123;</span><br><span class="line">  a=9;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">top.init();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//情景：点击按钮创建元素，弹出弹框</span><br><span class="line">// 实现弹窗</span><br><span class="line">var createWindow = function()&#123;</span><br><span class="line">    var div = document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML = &quot;我是弹窗内容&quot;;</span><br><span class="line">    div.style.display = &apos;none&apos;;</span><br><span class="line">    document.body.appendChild(&apos;div&apos;);</span><br><span class="line">    return div;</span><br><span class="line">&#125;;</span><br><span class="line">document.getElementById(&quot;Id&quot;).onclick = function()&#123;</span><br><span class="line">    // 点击后先创建一个div元素</span><br><span class="line">    var win = createWindow();</span><br><span class="line">    win.style.display = &quot;block&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//如上的代码；大家可以看看，有明显的缺点，比如我点击一个元素需要创建一个div，我点击第二个元素又会创建一次div，我们频繁的点击某某元素，他们会频繁的创建div的元素，虽然当我们点击关闭的时候可以移除弹出代码，但是呢我们频繁的创建和删除并不好，特别对于性能会有很大的影响，对DOM频繁的操作会引起重绘等，从而影响性能；因此这是非常不好的习惯；我们现在可以使用单体模式来实现弹窗效果，我们只实例化一次就可以了；如下代码：</span><br><span class="line">// 实现单体模式弹窗</span><br><span class="line">var createWindow = (function()&#123;</span><br><span class="line">    var div;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(!div) &#123;</span><br><span class="line">            div = document.createElement(&quot;div&quot;);</span><br><span class="line">            div.innerHTML = &quot;我是弹窗内容&quot;;</span><br><span class="line">            div.style.display = &apos;none&apos;;</span><br><span class="line">            document.body.appendChild(div);</span><br><span class="line">        &#125;</span><br><span class="line">        return div;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">document.getElementById(&quot;Id&quot;).onclick = function()&#123;</span><br><span class="line">    // 点击后先创建一个div元素</span><br><span class="line">    var win = createWindow();</span><br><span class="line">    win.style.display = &quot;block&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//上面的弹窗的代码虽然完成了使用单体模式创建弹窗效果，但是代码并不通用，比如上面是完成弹窗的代码，假如我们以后需要在页面中一个iframe呢？我们是不是需要重新写一套创建iframe的代码呢,所以就得用一套可以复用的代码来实现，代码如下：</span><br><span class="line"></span><br><span class="line">//[----------完整版-------------]</span><br><span class="line">// 创建div</span><br><span class="line">var createWindow = function()&#123;</span><br><span class="line">    var div = document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML = &quot;我是弹窗内容&quot;;</span><br><span class="line">    div.style.display = &apos;none&apos;;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">    return div;</span><br><span class="line">&#125;;</span><br><span class="line">// 创建iframe</span><br><span class="line">var createIframe = function()&#123;</span><br><span class="line">    var iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    return iframe;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取实例的封装代码</span><br><span class="line">var getInstance = function(fn) &#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result || (result = fn.call(this,arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试创建div</span><br><span class="line">var createSingleDiv = getInstance(createWindow);</span><br><span class="line">document.getElementById(&quot;Id&quot;).onclick = function()&#123;</span><br><span class="line">    var win = createSingleDiv();</span><br><span class="line">    win.style.display = &quot;block&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试创建iframe</span><br><span class="line">var createSingleIframe = getInstance(createIframe);</span><br><span class="line">document.getElementById(&quot;Id&quot;).onclick = function()&#123;</span><br><span class="line">    var win = createSingleIframe();</span><br><span class="line">    win.src = &quot;http://cnblogs.com&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>构造出特定类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//情景：小明和小王的房门有不一样的门的款式，那么我们就可以传递参数给制造商</span><br><span class="line">function zaomen(huawen)&#123;</span><br><span class="line">  if(!(this instanceof zaomen ))&#123;</span><br><span class="line">    return new zaomen();</span><br><span class="line">  &#125;</span><br><span class="line">  this.suo=&quot;普通&quot;;</span><br><span class="line">  var _huawen=&quot;普通&quot;;</span><br><span class="line">  if(huawen)&#123;</span><br><span class="line">    _huawen=huawen;</span><br><span class="line">  &#125;</span><br><span class="line">  this.huawen=_huawen;</span><br><span class="line">  this.create=function()&#123;</span><br><span class="line">    return &quot;【锁头】&quot;+this.suo+&quot;【花纹】&quot;+this.huawen;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a=new zaomen();</span><br><span class="line">console.log(a.create());</span><br><span class="line">var b=new zaomen();</span><br><span class="line">console.log(b.create(&quot;酷炫的门&quot;));</span><br></pre></td></tr></table></figure></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>将一个复杂的对象与表示分离，简单点讲就是我只要提出我的要求具体的事情怎么做我不要管<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//情景白富美想盖房子，找到包工头，包工头再找工人造房子</span><br><span class="line">function fanzhi()&#123;</span><br><span class="line">  this.chufan=&quot;&quot;;</span><br><span class="line">  this.ketin=&quot;&quot;;</span><br><span class="line">  this.toilet=&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function baogongtou()&#123;</span><br><span class="line">  this.gaifangzhi=function()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">funtcion gongren()&#123;</span><br><span class="line">  this._gaichufan=function()&#123;</span><br><span class="line">console.log(&quot;厨房改好了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">this._gaiketin=function()&#123;</span><br><span class="line">console.log(&quot;客厅盖好了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">this._gaitoilet=function()&#123;</span><br><span class="line">console.log(&quot;厕所盖好了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//交付房子</span><br><span class="line">this.jiafangzhi=function()&#123;</span><br><span class="line">var newfanzhi=new fanzhi();</span><br><span class="line">newfanzhi.chufan=&quot;ok&quot;;</span><br><span class="line">newfanzhi.ketin=&quot;ok&quot;;</span><br><span class="line">newfanzhi.toilet=&quot;ok&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var gonren_work=new gongren();</span><br><span class="line">var baogontou_order=new baogongtou();</span><br><span class="line">baogontou_order.gaifagnzhi(gongren);//包工头发出指令</span><br></pre></td></tr></table></figure></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单点讲就是解决多个相似的问题，工厂下还有对应的子类，比如一家工厂他下面还有生产衣服的子公司和生产鞋子的子公司，实际开发中我们用的也比较多，比如jquery中的$.ajax(url:’a.php’),a.php就是我这个厂长发出要制造的东西的指令，$.ajax这个方法就是工厂，他负责把这个指令传达给下面的子公司去完成，这里的子公司就是jquery后台代码封装的一些处理方法，也就是做具体的工作<br>缺点：不能知道对象识别的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//简单的工厂</span><br><span class="line">var factory=function()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  factory.createXMLHttp=function()&#123;</span><br><span class="line">  var xmlhttp=null;</span><br><span class="line">  if(window.XMLHttpRequest)&#123;</span><br><span class="line">  xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;else if(window.ActiveObject)&#123;</span><br><span class="line">  xmlhttp=new ActiveObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return xmlhttp;</span><br><span class="line">  &#125;</span><br><span class="line">  var hander=function()&#123;</span><br><span class="line">  var xmlhttp=factory.createXMLHttp();//具体的操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> //复杂的工厂</span><br><span class="line"> var xmlFactory=function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">xmlFactory.prototype=function()&#123;</span><br><span class="line">  //这个工厂是其他子工厂的总部，负责分工，不负责制造</span><br><span class="line">throw new Error(&apos;这不是我的工作&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var childFactory=function()&#123;</span><br><span class="line">xmlFactory.call(this);</span><br><span class="line">&#125;</span><br><span class="line">childFactory.prototype=new xmlFactory();//覆盖父厂的方法，这才是我的本职工作</span><br><span class="line">childFactory.prototype.constructor=childFactory;</span><br><span class="line">childFactory.prototype=function()&#123;</span><br><span class="line">// 这里面才是我真正工作的地方</span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">  xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;else if(window.ActiveObject)&#123;</span><br><span class="line">  xmlhttp=new ActiveObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return xmlhttp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>简单点讲就是通过中介替我们做事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//代理模式需要三方</span><br><span class="line">//买家</span><br><span class="line">function maijia()&#123;</span><br><span class="line">  this.namme=&quot;小明&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//中介</span><br><span class="line">function zhonjie()&#123;&#125;</span><br><span class="line">zhonjie.prototype.maifan=function()&#123;</span><br><span class="line">  new fandong(new maijia()).maifan(&quot;20万&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function fandong()&#123;</span><br><span class="line">  this.maijia_name=maijia.name;</span><br><span class="line">  this.maifan=function(money)&#123;</span><br><span class="line">  console.log(&apos;收到了来自&apos;+this.maijia_name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(new zhongjie).maifan();</span><br><span class="line"></span><br><span class="line">//例子2</span><br><span class="line">var naicha=function(name)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">var ceo=function(girl)&#123;</span><br><span class="line">this.girl=girl;</span><br><span class="line">this.sendRing=function(ring)&#123;</span><br><span class="line">   console.log(&quot;我要送个&quot;+ring+&quot;给&quot;+this.girl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var zhuli=function(girl)&#123;</span><br><span class="line">this.girl=girl;</span><br><span class="line">this.sendGift=function(gift)&#123;</span><br><span class="line">new ceo(this.girl).sendRing(gift);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var proxy=new zhuli(new naicha(&quot;奶茶妹&quot;));</span><br><span class="line">proxy.sendGift(&quot;钻石&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>用来对方法调用进行参数化的处理和传送，经过这样处理过的方法调用可以在任何需要的时候执行，比如司令发布一个作战指令给连长，连长发布命令给小分队，然后上级可以先将一二分队先上，三四分队后上这就是参数化的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var lian=&#123;&#125;</span><br><span class="line">    //炮兵</span><br><span class="line">    lian.paobin=function(pao_num)&#123;</span><br><span class="line">    console.log(pao_num+&quot;炮&quot;+&quot;开始战斗&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //步兵出动人数</span><br><span class="line">    lian.bubin=function(bubin_num)&#123;</span><br><span class="line">    console.log(bubin_num+&quot;人&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //连长接收命令</span><br><span class="line">    lian.lianzhan=function(minlin)&#123;</span><br><span class="line">    lian[minlin.type](minlin.num);</span><br><span class="line">    &#125;</span><br><span class="line">    //司令发出作战指令</span><br><span class="line">    lian.lianzhan(&#123;</span><br><span class="line">    type:&quot;bubin&quot;,</span><br><span class="line">num:200</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>也叫作订阅者模式，定义了一种一对多的关系，多个观察者同时监听某个主题对象，当主题对象发生改变的时候，多个观察者都会收到信息</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类（对象）的接口（方法和属性）转化才能成客户希望的另外的一种接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//原本是这样写的</span><br><span class="line">var a=&#123;</span><br><span class="line">test:unction()&#123;&#125;,</span><br><span class="line">go:function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">a.test()</span><br><span class="line">//上面这样的写就是一个静态的object了，如果我加入一个对象里面存在同名的属性就会覆盖原有的属性</span><br><span class="line">//重构成下面这样子的</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.test=function()&#123;</span><br><span class="line">  console.log(&quot;这是新的test&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.gogo=function()&#123;</span><br><span class="line">console.log(&quot;这是新的gogo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//如果像之前a.test()这样访问的是不行的，所以就得需要一个适配器来解决重构对自己的代码带来的影响</span><br><span class="line">function filter()&#123;</span><br><span class="line">var newA=new a();</span><br><span class="line">var a=&#123;</span><br><span class="line">test:function()&#123;</span><br><span class="line">  newA.test();</span><br><span class="line">&#125;,</span><br><span class="line">go:function()&#123;</span><br><span class="line">  newA.gogo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">var a=filter();</span><br><span class="line">a.test();//这样就可以像之前那样访问了</span><br></pre></td></tr></table></figure></p><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>使多个对象有机会同时处理请求，避免发送者和接受者的耦合关系，将这个对象形成一条链，沿着这条链，直到有一个对象处理他为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//给老板一个写代码的任务，老板不会就交给了项目经理，项目经理不会就交给了程序狗</span><br><span class="line">function laoban(xianmujinli)&#123;</span><br><span class="line">   if(xianmujinli)&#123;</span><br><span class="line">   this.xianmujinli=xianmujinli;//把项目经理写代码的能力赋予自己</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">laoban.prototype.write=function(php)&#123;</span><br><span class="line">   this.xianmujinli.write(php)</span><br><span class="line">&#125;</span><br><span class="line">function xianmujinli(corder)&#123;</span><br><span class="line">  if(corder)&#123;</span><br><span class="line">    this.corder=corder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xianmujinli.prototype.write=function(php)&#123;</span><br><span class="line">  this.corder.write(php);</span><br><span class="line">&#125;</span><br><span class="line">function corder(php)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">corder.prototype.write=function(php)&#123;</span><br><span class="line">  console.log(&quot;cord.....&quot;+php);</span><br><span class="line">&#125;</span><br><span class="line">var begin=new laoban(new xianmujinli(new corder()))</span><br><span class="line">begin.write(&apos;php&apos;);</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://lenshen.com/2016/03/07/js-design-pattern/#more" target="_blank" rel="noopener">地址1</a> | <a href="http://www.cnblogs.com/tugenhua0707/p/5198407.html" target="_blank" rel="noopener">地址2</a><br>作者：<a href="https://chenjiaobin.github.io/about/" target="_blank" rel="noopener">陈焦滨#kevin</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2017/10/15/%E9%97%AD%E5%8C%85/"/>
      <url>/2017/10/15/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>闭包是指有权访问另一个函数作用域中的变量的函数，简单点就是一个函数内部创建另个函数。<a id="more"></a></p><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>简单点讲就是当前的函能够访问另外一个函数作用域中的变量，但是我们要这么分析他在js中到底是怎么运行的，当函数创建的时候，会创建一个预先包含全局变量对象的作用域链，当我们访问执行完函数的时候就会生成一个执行环境，这个执行环境的作用域链复用了刚才的那个作用域链并添加属于自身的活动变量，当函数执行结束的时候这个执行环境就会被回收 ，所以就不存在闭包这个东西，但是当函数应用了其他函数的变量的时候，那么当我们执行完函数后因为他应用了外部作用域的变量，牵扯到了外部函数的执行环境，但是理论来说外部函数执行完后执行环境就会被回收，那么如果按照这个理论的话那么这里的执行就会出现问题，因为内部函数的执行的时候就会找不到外部的变量。为了避免这个问题出现，javascript就将外部作用域的变量保存了下来，也就是外部作用域的信息被保存了下来，也因此有了闭包有可能会导致内存泄漏的这个概念</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>后台的每个执行环境都有一个表示变量的对象–变量对象。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在创建函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[scope]]属性中，当调用函数的时候，会为函数创建一个执行环境，然后通过复制函数的[[scope]]属性中的对象构建起执行环境的作用域链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。<br>闭包只能取得包含函数中任何变量的最后一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//错误</span><br><span class="line">function a()&#123;</span><br><span class="line">  var arr=new Array();</span><br><span class="line">  for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    arr[i]=function()&#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">输出的数组的值都是10</span><br><span class="line">//正确</span><br><span class="line">function a()&#123;</span><br><span class="line">  var arr=new Array();</span><br><span class="line">  for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    arr[i]=function()&#123;</span><br><span class="line">      return function()&#123;</span><br><span class="line">        return i;</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>由于IE9之前的版本对JScript对象和com对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题，那么，如果闭包的作用域链中保存着一个HTML元素，那么久意味着该元素无法销毁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var ele=document.getElementById(&quot;box&quot;);</span><br><span class="line">  ele.onclick=function()&#123;</span><br><span class="line">    alert(ele.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//由于匿名函数保存了一个对a函数的活动对象ele的引用，因此就会导致无法减少ele的引用数，只要匿名函数存在，ele的引用书至少也是1，因此他占用的内存永远无法被回收</span><br><span class="line"></span><br><span class="line">//优化</span><br><span class="line">function a()&#123;</span><br><span class="line">  var ele=document.getElementById(&quot;box&quot;);</span><br><span class="line">  var id=ele.id;</span><br><span class="line">  ele.onclick=function()&#123;</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;</span><br><span class="line">  ele=null;</span><br><span class="line">&#125;</span><br><span class="line">这样就不会出现上面那个问题了</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stickFooter</title>
      <link href="/2017/10/13/stickyFooter/"/>
      <url>/2017/10/13/stickyFooter/</url>
      
        <content type="html"><![CDATA[<p>如果页面内容不够长的时候，页脚块粘贴在视窗底部；如果内容足够长时，页脚块会被内容向下推送。<a id="more"></a></p><h3 id="普通css的解决方案"><a href="#普通css的解决方案" class="headerlink" title="普通css的解决方案"></a>普通css的解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html,body&#123;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 100%;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.space&#123;</span><br><span class="line">min-height: 100%;//这个百分比比较重要</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">background-color: red;</span><br><span class="line">height: 500px;</span><br><span class="line">padding-bottom: 32px;//这个是为了当页面高于屏幕宽度时能够保持底部在他下面</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">height: 32px;</span><br><span class="line">background: green;</span><br><span class="line">margin: -32px auto 0 auto ;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;space&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;这是什么鬼&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="FlexBox解决方案"><a href="#FlexBox解决方案" class="headerlink" title="FlexBox解决方案"></a>FlexBox解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html,body&#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-flow: column; //重要</span><br><span class="line">width: 100%;</span><br><span class="line">height: 100%;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.header&#123;</span><br><span class="line">background-color: red;</span><br><span class="line">/*height: 100px;*/</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">background-color: green;</span><br><span class="line">flex:1; //设置了这个才能使得中间的容器能将剩余的页面撑满，也就是页面始终是占满视口，很重要</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">background-color: orange;</span><br><span class="line">/*height: 100px;*/</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--这个header必须有内容才能撑开--&gt;</span><br><span class="line">&lt;div class=&quot;header&quot;&gt;dfasda&lt;/div&gt; </span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">&lt;p&gt;这是什么鬼&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--这个footer必须有内容才能撑开--&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;sfdasfs&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
            <tag> stickyFooter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax与Comet</title>
      <link href="/2017/10/11/Ajax/"/>
      <url>/2017/10/11/Ajax/</url>
      
        <content type="html"><![CDATA[<p>Ajax的主要作用是实现在不刷新页面的情况下实现局部异步更新数据。<a id="more"></a></p><h3 id="原生js实现ajax请求代码"><a href="#原生js实现ajax请求代码" class="headerlink" title="原生js实现ajax请求代码"></a>原生js实现ajax请求代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//get请求方式</span><br><span class="line">var xmlhttp</span><br><span class="line">function xml()&#123;</span><br><span class="line">  if(window.XMLHttpRequest)&#123;</span><br><span class="line">    xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    xmlhttp=new ActicveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.onreadystatechange=function()&#123;</span><br><span class="line">    if(xmlhttp.statue==200&amp;&amp;xmlhttp.readyState==4)&#123;</span><br><span class="line">        var responseText=JSON.parse(xmlhttp.responseText);</span><br><span class="line">        //这里返回数据后的处理过程了，我就不写了</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.open(&quot;GET&quot;,&quot;http://www.baidu.com&quot;,true);//第三个参数表示时候异步，true就是异步</span><br><span class="line">  xmlhttp.send(null);//这里面可以传递一个参数，如果不要作为请求主体发送的数据，就不需要加上这个参数，这个参数需要序列化之后才能传进去，即stringify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//POST请求</span><br><span class="line">function xml()&#123;</span><br><span class="line">  if(window.XMLHttpRequest)&#123;</span><br><span class="line">    xmlhttp=new XMLHttpRequest();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    xml=new ActicveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.onreadystatechange=function()&#123;</span><br><span class="line">    if(xmlhttp.statue==200&amp;&amp;xmlhttp.readyState)&#123;</span><br><span class="line">        var responseText=JSON.parse(xmlhttp.responseText);</span><br><span class="line">        //这里返回数据后的处理过程了，我就不写了</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.open(&quot;POST&quot;,&quot;http://www.baidu.com&quot;,true);//第三个参数表示时候异步，true就是异步</span><br><span class="line">  xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//如果是post请求的话就得加上这一句，因为加上这一句的就可以像表单一样获取到对应的参数，比如在php中就可以通过$_post这个超级全局变量获取到信息，如果不加这一句的话就在再$_post找不到数据</span><br><span class="line">  xmlhttp.send(null);//这里面可以传递一个参数，如果不要作为请求主体发送的数据，就不需要加上这个参数，这个参数需要序列化之后才能传进去，即stringify</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readyState各状态代表什么"><a href="#readyState各状态代表什么" class="headerlink" title="readyState各状态代表什么"></a>readyState各状态代表什么</h3><ul><li>0：未初始化，尚未调用open()方法</li><li>1：启动，已经调用open方法，尚未调用send方法</li><li>2：发送，已经抵用send方法，尚未收到响应</li><li>3：接收，已经接收到部分数据，</li><li>4：接收全部完成<h3 id="JQuery实现ajax请求"><a href="#JQuery实现ajax请求" class="headerlink" title="JQuery实现ajax请求"></a>JQuery实现ajax请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type:&quot;POST&quot;,</span><br><span class="line">  url:&quot;/api&quot;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    name:&quot;chen&quot;,</span><br><span class="line">    age:&quot;bibi&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dataType:&quot;json&quot;, //可以死json,xml,string</span><br><span class="line">  async:true, //默认true</span><br><span class="line">  success:function(data)&#123;</span><br><span class="line">    //这里的data不用通过JSON.parse转化了</span><br><span class="line">  &#125;,</span><br><span class="line">  error:function(xhr,status,errorThrown)&#123;</span><br><span class="line">    console.log(xhr.state);//获取到错误码400等</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">    console.log(xhr.readyState);//状态1,2,3,4</span><br><span class="line">    console.log(status);//null, timeout, error, abort, parsererror </span><br><span class="line">    console.log(errorThrown);//收到http出错文本，如 Not Found 或 Internal Server Error</span><br><span class="line">  &#125;</span><br><span class="line">  complete:function(xhr,status)&#123;</span><br><span class="line">    //第一个参数</span><br><span class="line">    console.log(xhr.responseText);//这里返回的值跟success返回的data值是一样的,它还可以xhr.status  xhr.readyState</span><br><span class="line">    //第二个参数表示的是success或者error</span><br><span class="line">    console.log(status);//success,notmodified,nocontent,error,timeout,abort,parsererror</span><br><span class="line">    if(status==&quot;timeout&quot;)&#123;</span><br><span class="line">      var xmlhttp=window.XMLHttpRequest?new window.XMLHttpRequest():new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);</span><br><span class="line">      xmlhttp.abort();//中断请求</span><br><span class="line">      $(&quot;#a&quot;).html(&quot;请求超时&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeSend:function()&#123;</span><br><span class="line">    //这个是最先执行的，如果spiner图片可以在数据为拿到之前显示这个图片</span><br><span class="line">  &#125;,</span><br><span class="line">  cache:false //如果数据经常变化的话就最好设置成false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="JQuery的get请求"><a href="#JQuery的get请求" class="headerlink" title="JQuery的get请求"></a>JQuery的get请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//第二个参数会在执行过程中自动加到/api后面，即/api?action=get&amp;name=chen</span><br><span class="line">//$.get(url,[data],[callback])</span><br><span class="line"></span><br><span class="line">$.get(&quot;/api&quot;,&#123;action:&quot;get&quot;,name:&quot;chen&quot;&#125;,function(data,textStatus)&#123;</span><br><span class="line">//如果成功的话textState的值是success,只有成功才能进入这个回调函数</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="JQery单个post方式请求"><a href="#JQery单个post方式请求" class="headerlink" title="JQery单个post方式请求"></a>JQery单个post方式请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//$.post(url,[data],[callback],[type]) type是客户端请求的类型json,xml等</span><br><span class="line"></span><br><span class="line">$.post(&quot;/api&quot;,&#123;action:&quot;get&quot;,name:&quot;chen&quot;&#125;,function(data,textStatus)&#123;</span><br><span class="line">//如果成功的话textState的值是success,只有成功才能进入这个回调函数</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Ajax上传文件可以通过FormData"><a href="#Ajax上传文件可以通过FormData" class="headerlink" title="Ajax上传文件可以通过FormData"></a>Ajax上传文件可以通过FormData</h3><p>因为有时候表单提交可能需要提交附件，那么如果用ajax普通方式来提交的话就会出现问题，因为form表单默认的编码方式是<code>application/x-www-form-urlencoded</code>,这种编码方式只能编码文本类型的数据，因此Ajax发送请求的时候，会把data序列化成 一个个String类型的键值对,此种传输数据的方式能够满足大部分应用场景，然而当传输的数据里有附件的时候，此序列化机制便是我们的绊脚石。FormData是html5的接口，使用它一行代码便可以拿到整个form表单对象：<code>var form = new FormData(document.getElementById(&quot;form&quot;))</code>,记住，如果不是用<code>document.getElementById(&quot;form&quot;)</code>获取数据，而是通过<code>$(&quot;#form&quot;)[0]</code>切记切记要在后面加上这个<code>[0]</code>,这是我踩过的坑，太狗血了。我们拿着获取到的这个form对象，去赋给Ajax的data，并且阻止它将参数转成成String类型的键值对，此举需要设置processData属性为false，此属性默认为true；同时设置Ajax的编码方式为false（contentType: false），在form表单里已经设置了编码方式，Ajax的编码机制已经不需要，这样我们就可以用Ajax去提交一个form对象，从而解决表单有附件的问题。需要注意的是，务必将Ajax的提交方式，设置为post，get请求只能携带几kb的数据。若是不设置processData为false，去提交带附件的form同样是提交不上去的，它的序列化机制是硬伤。所以提交的时候，只能不使用它的序列化机制。用这个formdata可以不用再form表单的标签上设置<code>enctype=&quot;multipart/form-data&quot;</code>,话不多说，看代码吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var formData=new FormData($(&quot;#form&quot;)[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&apos;接口地址&apos;,</span><br><span class="line">  type:&apos;post&apos;,</span><br><span class="line">  data:formData,</span><br><span class="line">  cache:false,</span><br><span class="line">  processData:false,</span><br><span class="line">  contentType:false,</span><br><span class="line">  success:function(data)&#123;</span><br><span class="line">    .....写自己的东西</span><br><span class="line">    &#125;</span><br><span class="line">  error:function(xhr,status)&#123;</span><br><span class="line">    console.log(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>情景：一个表单里面有提交文件的表单字段，点击type=”file”后选择文件，可以多次点击选择不同的文件，然后先异步上传到服务器的临时目录也就是缓存目录，当点击提交表单的时候提交全部文件<br>做法：我们每次点击选择完文件后就触发一个ajax去上传文件到缓存目录，上传成功后我们就动态生成一个input[type=”checkbox”],并且将上传文件后返回的id的值赋值到checkout的value上，这样我们提交表单后后台可以通过复选框的这些id去缓存目录找到对应的文件然后上传到服务器的真实目录上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; id=&quot;uploadFile&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function uploadFile()&#123;</span><br><span class="line">var formData=new FormData();</span><br><span class="line">formData.append(&quot;file&quot;,$(&quot;#uploadFile&quot;)[0].files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&apos;../../plugins/servlet/fileupload&apos;,</span><br><span class="line">type:&apos;post&apos;,</span><br><span class="line">data:formData,</span><br><span class="line">cache:false,</span><br><span class="line">processData:false,//阻止它将参数转成string类型的键值对</span><br><span class="line">contentType:false,//设置ajax的编码方式为false</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">console.log($(&quot;#uploadFile&quot;)[0].files[0].name);</span><br><span class="line">$(&quot;.uploadFile&quot;).append(&quot;&lt;input type=&apos;checkbox&apos; class=&apos;fileTemp&apos; checked=&apos;checked&apos; name=&apos;fileTemp&apos; id=&quot;+data+&quot; value=&quot;+data+&quot;&gt;&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">error:function(xhr,status)&#123;</span><br><span class="line">console.log(status);</span><br><span class="line">&#125;,</span><br><span class="line">complete:function(XMLHttpRequest,xhr)&#123;</span><br><span class="line">    //这里主要是来做进度条的</span><br><span class="line">var tempID=XMLHttpRequest.responseText;</span><br><span class="line">$(&quot;.pregressBar:last&quot;).attr(&quot;data-temp&quot;,tempID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//这样的话每次选择文件都会触发一次ajax，每次都会动态添加一个input[type=&quot;checkbox&quot;]</span><br><span class="line">//我生成这个input也是为了做进度条的，每次点击都会触发这个ajax，还触发了另外一个实时获取进度条的ajax，另外一个ajax是通过setTimeout定时器来不断的发送请求获取进度百分比的，这个我就不在这里写了</span><br></pre></td></tr></table></figure></p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>概念：JavaScript的对象变现法<br>优点：读写速度快，简短，javascript内建的方法直接解析stringify和parse<br>注意：键值对必须用<code>双引号</code>，不能用单引号<br>json的值可以是：数组，对象，数字，字符串，null</p><ul><li><p>JSON.parse()<br>这个的作用是将JSON字符串<code>&#39;{&quot;name&quot;:&quot;chen&quot;}&#39;</code>转换成javascript的json对象也就是普通的对象<code>{name:&quot;chen&quot;}</code>,他可以传递一个参数，这个参数对每个键值对都会进行过滤筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&quot;name&quot;:&quot;chen&quot;,&quot;age&quot;:12&#125;</span><br><span class="line">var b=JSON.parse(a,function(key,value)&#123;</span><br><span class="line">  if(key===&quot;age&quot;)&#123;</span><br><span class="line">    value=14;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(b);</span><br><span class="line">最后输出的是&#123;name:&quot;chen&quot;,age:14&#125;</span><br></pre></td></tr></table></figure></li><li><p>JSON.stringify()<br>这个的作用是将对象转换成json字符串，也就是<strong>序列化</strong>的过程。可以传递其他两个参数，第一个参数是过滤器，可以是数组，也可以是一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&quot;name&quot;:&quot;chen&quot;,&quot;age&quot;:12&#125;</span><br><span class="line">//函数的时候</span><br><span class="line">var b=JSON.stringify(a,function(key,value)&#123;</span><br><span class="line">  if(key===&quot;age&quot;)&#123;</span><br><span class="line">    value=14;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(b);</span><br><span class="line">最后输出的是&#123;&quot;name&quot;:&quot;chen&quot;,&quot;age&quot;:14&#125;</span><br><span class="line"></span><br><span class="line">//数组的时候</span><br><span class="line">var b=JSON.stringify(a,[&quot;name&quot;]);</span><br><span class="line">console.log(b)</span><br><span class="line">最后输出的是&#123;&quot;name&quot;:&quot;chen&quot;&#125;</span><br><span class="line"></span><br><span class="line">//第三个参数是字符串缩进</span><br><span class="line">var b=JSON.stringify(a,null,&quot;--&quot;);</span><br><span class="line">console.log(b)</span><br><span class="line">最后输出的是</span><br><span class="line">&#123;</span><br><span class="line">--&quot;name&quot;:&quot;chen&quot;,</span><br><span class="line">--&quot;age&quot;:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="JSON和XML的相互转换"><a href="#JSON和XML的相互转换" class="headerlink" title="JSON和XML的相互转换"></a>JSON和XML的相互转换</h3><p>需要下载：jquery / jquery.json2xml.js / jquery.xml2json.js</p><ul><li><p>xml转换成json对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;&quot;;</span><br><span class="line">str+=&quot;&lt;root&gt;&quot;;</span><br><span class="line">str+=&quot;&lt;name&gt;chen&lt;/name&gt;&quot;;</span><br><span class="line">str+=&quot;&lt;age&gt;32&lt;/age&gt;&quot;;</span><br><span class="line">str+=&quot;&lt;/root&gt;&quot;;</span><br><span class="line">var obj=$.xml2json(str);</span><br><span class="line">console.log(str);//结果是&#123;name:&quot;chen&quot;,age:32&#125;</span><br><span class="line">var json=JSON.stringify(obj)//输出是&#123;&quot;name&quot;:&quot;chen&quot;,&quot;age&quot;:32&#125;</span><br></pre></td></tr></table></figure></li><li><p>json对象转换成xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;name:&quot;chen&quot;,age:43&#125;;</span><br><span class="line">$.json2xml(a);//输出是&lt;root&gt;&lt;name&gt;chen&lt;/name&gt;&lt;age&gt;43&lt;/age&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="GeoJSON和TopoJSON"><a href="#GeoJSON和TopoJSON" class="headerlink" title="GeoJSON和TopoJSON"></a>GeoJSON和TopoJSON</h3><p>测试工具：geojson.io<br>这两种是符合JSON数据格式的表示地理信息</p><ul><li>GeoJSON<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;:&quot;point&quot;, //表示点,LineString表示面</span><br><span class="line">  &quot;coordinates&quot;:[-105,39]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>当协议，子域名，主域名，端口号任意一个不同就是跨域<br>javascript的同源策略是对XHR的主要约束，他为通信设置了“相同的域、相同的端口、相同的协议”，视图访问上述限制外的资源会引发安全错误，那么就需要跨域解决方案，这个解决方案就是<strong>CORS(跨源资源共享)</strong> IE8通过XDR（XDomainRequest）对象支持CORS，其他浏览器通过XHR对象原生支持CORS。图像PING和JSONP也类似于CORS，也是解决跨域通信的技术。</p><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><ul><li>代理，主要是在后端人员操作，比如北京有一台服务器<a href="http://www.beijin.com" target="_blank" rel="noopener">www.beijin.com</a> 想访问上海服务器 <a href="http://www.shanhai.com" target="_blank" rel="noopener">www.shanhai.com</a> 那么我们就只需要在在北京服务器上做一个代理服务器即与北京服务器是同源的<a href="http://www.beijin.com/prox" target="_blank" rel="noopener">www.beijin.com/prox</a> 然后通过这个代理去访问上海服务器的数据，然后我们前端只需要获取数据只要访问<a href="http://www.beijin.com/prox" target="_blank" rel="noopener">www.beijin.com/prox</a> 就好了</li><li>JSONP，可用于解决主流浏览器的跨域数据访问问题（不支持post请求,还有就是JSONP死是从其他域中加载代码执行，如果其他域不安全，那么web服务就不安全了）<br>例子1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在www.aaa.com页面中声明一个函数</span><br><span class="line">&lt;script src=&quot;http://www.bbb.com/jsonp.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function jsonp(json)&#123;</span><br><span class="line">    console.log(json[&quot;name&quot;]);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在www.bbb.com页面中</span><br><span class="line">jsonp(&#123;&quot;name&quot;:&quot;chen&quot;&#125;)</span><br><span class="line">以上的执行时a域名声明，b域名调用</span><br></pre></td></tr></table></figure></li></ul><p>例子2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//前端</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type:&quot;GET&quot;,</span><br><span class="line">  url:&quot;/api&quot;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    name:&quot;chen&quot;,</span><br><span class="line">    age:&quot;bibi&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dataType:&quot;jsonp&quot;,//改成jsonp</span><br><span class="line">  jsonp:&quot;call&quot;,//call随便都可以</span><br><span class="line">  success:function(data)&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line">  error:function(xhr)&#123;</span><br><span class="line">    console.log(xhr.state);//获取到错误码400等</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//后端php</span><br><span class="line">$jsonp=$_GET[&quot;call&quot;];</span><br><span class="line">$result=$jsonp.&apos;(&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;错误&quot;&#125;)&apos;; //返回的数据必须用$.jsonp.(&#123;...&#125;)连接起来</span><br></pre></td></tr></table></figure></p><ul><li>XHR2</li></ul><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术<br>两种实现Comet的方式：<strong>长轮询和流</strong>。长轮询是传统轮询的翻版<br><strong>长轮询和短轮询的区别</strong><br>短轮询是服务器立即发送响应，无论数据是否有效，<br>长轮询是页面发起请求，服务器一直保持连接打开，知道有数据发送，发送完数据之后，浏览器关闭连接，随即又发起到一个到服务器的新请求<br>HTTP流，流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> comet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knockout</title>
      <link href="/2017/10/11/Knockout%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2017/10/11/Knockout%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这是一个js的MVVM(Module-view-ViewModel)框架,这个方便了前端开发者可以不用去写大量的dom交互。它的兼容性也比较好，IE6以上和firfox上应用的都没什么问题。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>引入jQuery.min.js,引入Knockout.js，<a href="https://github.com/knockout/knockout/releases" target="_blank" rel="noopener">Knockout.js下载地址</a></li><li>定义构造函数–实例化–绑定，代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//构造函数，定义在标签上要绑定的名字和数据</span><br><span class="line">var ViewModule=function()&#123;</span><br><span class="line">  var self=this;</span><br><span class="line">  self.gg=ko.observable(&quot;测试&quot;);</span><br><span class="line">  self.userName=ko.observable();</span><br><span class="line">  self.city=ko.observableArray([&apos;深圳&apos;,&apos;广州&apos;,&apos;上海&apos;]);</span><br><span class="line">  self.hobby=ko.observableArray([&#123;key:&apos;10001&apos;,value:&apos;篮球&apos;&#125;,&#123;key:&apos;10002&apos;,value:&apos;羽毛球&apos;&#125;])</span><br><span class="line">  self.selectedHobby=ko.observable();</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModule=new ViewModule();//实例化</span><br><span class="line">ko.applyBindings(currentViewModule);//绑定</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//html，应用上面js绑定好的数据</span><br><span class="line">&lt;div data-bind=&quot;html:gg&quot;&gt;&lt;/div&gt;//这里面会输出‘测试’</span><br><span class="line">&lt;input type=&quot;text&quot; data-bind=&quot;value:userName&quot;&gt;</span><br><span class="line">&lt;p data-bind=&quot;html:userName&quot;&gt;&lt;/p&gt;//每次在上面的input输完东西后鼠标离开后都会将输入的数据填入到这个p标签里面</span><br><span class="line">&lt;select data-bind=&quot;options:hobby,selectedOptions:selectedHobby,optionsCaption:&apos;--请选择--&apos;,optionsText:&apos;key&apos;,optionsValue:&apos;value&apos;&quot;&gt;&lt;/select&gt;</span><br><span class="line">&lt;b data-bind=&quot;html:selectedHobby&quot;&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><p>接下来来点比较好用的</p><p>###<br><strong>点击事件和循环遍历</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;id&lt;/th&gt;</span><br><span class="line">&lt;th&gt;name&lt;/th&gt;</span><br><span class="line">&lt;th&gt;des&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody data-bind=&quot;foreach:arr&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td data-bind=&quot;html:$index&quot;&gt;&lt;/td&gt;//$index是konckout自带的参数，自动计算个数进行0,1,2,3...</span><br><span class="line">&lt;td data-bind=&quot;html:(name==&apos;月球&apos;?&apos;这是嫦娥的家&apos;:name)&quot;&gt;&lt;/td&gt;//还可以进行条件判断</span><br><span class="line">&lt;td data-bind=&quot;html:des&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">//循环遍历输出值还可以同过$data循环输出&lt;tbody data-bind=&quot;foreach:arr&quot;&gt;&lt;tr data-bind=&quot;text:$data&quot;&gt;&lt;/tr&gt;&lt;/tbody&gt;</span><br><span class="line">&lt;button data-bind=&quot;click:addOne&quot;&gt;添加一个星球&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">var arr=[</span><br><span class="line">&#123;id:1,name:&quot;火星&quot;,des:&quot;火星探索&quot;&#125;,</span><br><span class="line">&#123;id:2,name:&quot;月球&quot;,des:&quot;月球探索&quot;&#125;,</span><br><span class="line">&#123;id:3,name:&quot;地球&quot;,des:&quot;人类居住的地方&quot;&#125;</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line">  var ViewModule=function()&#123;</span><br><span class="line">  var self=this;</span><br><span class="line">  self.arr=ko.observableArray(arr);</span><br><span class="line">  self.addOne=function()&#123;</span><br><span class="line">     self.arr.push(&#123;id:&quot;4&quot;,name:&quot;接口的&quot;,des:&quot;d快递费&quot;&#125;);</span><br><span class="line">     return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModule=new ViewModule();//实例化</span><br><span class="line">ko.applyBindings(currentViewModule);//绑定</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>自定义输出格式</strong><br>在看代码的时候先看下computed的概念和pureComputed的概念，我就不说概念了，直接以最简单的方式表达</p><ol><li>computed：当用户需要显示自己处理后的数据的时候，那就需要用到它了，它是依赖其他observable,就是通过observable定义好的数据，通过computed来处理这个定义好的数据在其他地方显示，就像下面的date，输入年月日后，在下面的总时间显示特定的格式</li><li>pureComputed:当用户既要显示自定义后的数据又要通过修改制定后的数据同时也更新observable的数据，那这时候就可以用到pureComputed了，就像下面的pureComputed<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;value:year&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;value:month&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;value:day&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;value:date2&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">  var ViewModule=function()&#123;</span><br><span class="line">  var self=this;</span><br><span class="line"> self.year=ko.observable(&quot;&quot;);</span><br><span class="line">self.month=ko.observable(&quot;&quot;);</span><br><span class="line">self.day=ko.observable(&quot;&quot;);</span><br><span class="line">//注意：computed和pureComputed的区别就是computed不能双向绑定，就是我现在跟在了year或month或day里面的值会改变date的值，但是改变date里面的值不会改变year和month和day的值，但是pureComputed可以做到</span><br><span class="line">//注意：computed的应用是为了让</span><br><span class="line">self.date=ko.computed(function()&#123;</span><br><span class="line">  return self.year()+&quot;年&quot;+self.month()+&quot;月&quot;+self.day()+&quot;日&quot;</span><br><span class="line">&#125;)</span><br><span class="line">//下面这个比较厉害点</span><br><span class="line">self.date2=ko.pureComputed(&#123;</span><br><span class="line">  write:function(value)&#123;</span><br><span class="line">    var y=value.indexOf(&quot;年&quot;);</span><br><span class="line">    var m=value.indexOf(&quot;月&quot;);</span><br><span class="line">    var d=value.indexOf(&quot;日&quot;);</span><br><span class="line">    self.year(value.substring(0,y));</span><br><span class="line">    self.month(value.substring(y+1,m));</span><br><span class="line">    self.day(value.substring(m+1,d));</span><br><span class="line">  &#125;,</span><br><span class="line">  read:function()&#123;</span><br><span class="line">    return self.year()+&quot;年&quot;+self.month()+&quot;月&quot;+self.day()+&quot;日&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">  owner:self</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModule=new ViewModule();//实例化</span><br><span class="line">ko.applyBindings(currentViewModule);//绑定</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>多个事件的绑定</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;b data-bind=&quot;html:count,style:&#123;color:styleColor&#125;,visible:count()&gt;3&quot;&gt;&lt;/b&gt;//千万要记住count()要加上括号</span><br><span class="line">&lt;button data-bind=&quot;event:&#123;click:addCount,mouseover:mouseOverEvent,mouseout:mouseOutEvent&#125;&quot;&gt;点击我把&lt;/button&gt;</span><br><span class="line">//传递参数bind,第一个参数是默认值就是viewModel对象，另一个缺省值是event指的是当前点击的对象,所以要传递参数是从第二个参数开始</span><br><span class="line">&lt;button data-bind=&quot;event:&#123;click:sure.bind($data,&apos;参数1&apos;,&apos;参数2&apos;)&#125;&quot;&gt;确定&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    var moduleView=function()&#123;</span><br><span class="line">    self.count=ko.observable(0);</span><br><span class="line">self.styleColor=ko.observable(&quot;black&quot;);</span><br><span class="line">self.addCount=function()&#123;</span><br><span class="line">var currentCount=self.count();</span><br><span class="line">var currentCount=currentCount+1;</span><br><span class="line">self.count(currentCount);</span><br><span class="line">&#125;;</span><br><span class="line">self.mouseOverEvent=function()&#123;</span><br><span class="line">self.styleColor(&quot;red&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">self.mouseOutEvent=function()&#123;</span><br><span class="line">self.styleColor(&quot;black&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">self.sure=function(params)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var currentModuleView=new modulwView();</span><br><span class="line">    ko.applyBindings(currentModuleView);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>定义组件</strong><br>关键词：components\register\viewModel\template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//两种方式引入组件</span><br><span class="line">&lt;div data-bind=&quot;component:&apos;messageList&apos;&quot;&gt;&lt;/div&gt;//组件名字必须以字符串的方式引入，就是要用引号引入</span><br><span class="line">&lt;div data-bind=&quot;component:&#123;name:&apos;messageList&apos;,params:&apos;chenjiaobin&apos;&#125;&quot;&gt;&lt;/div&gt;//可以传递一个params的参数</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">ko.components.register(</span><br><span class="line">&apos;messageList&apos;,&#123;</span><br><span class="line">viewModel:function(params)&#123;//这个viewModule的名字不能改，必须是这个</span><br><span class="line">var self=this;</span><br><span class="line">self.account=ko.observable(params!=null?params:&quot;tom&quot;);</span><br><span class="line">self.message=ko.observable(&quot;&quot;);</span><br><span class="line">self.send=function()&#123;</span><br><span class="line">self.messages.push(&#123;mes:self.message(),num:self.account()&#125;);</span><br><span class="line">self.message(&quot;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">self.messages=ko.observableArray([]);</span><br><span class="line">&#125;,</span><br><span class="line">template:&apos;&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;value:message&quot;&gt;&lt;button data-bind=&quot;click:send&quot;&gt;发送&lt;/button&gt;&lt;ul data-bind=&quot;foreach:messages&quot;&gt;&lt;li&gt;&lt;span data-bind=&quot;html:num&quot;&gt;&lt;/span&gt;&lt;span data-bind=&quot;html:mes&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">ko.applyBindings();</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>级联</strong><br>这个demo主要涉及到的是select选择器,属性options/optionsCaption/optionsText/optionsValue/value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;select data-bind=&quot;options:cityWrap,optionsCaption:&apos;--请选择城市--&apos;,optionsText:&apos;name&apos;,optionsValue:&apos;code&apos;,value:cs&quot;&gt;&lt;/select&gt;</span><br><span class="line">&lt;select data-bind=&quot;options:currentCity,optionsCaption:&apos;--请选择地区--&apos;,optionsText:&apos;name&apos;,optionsValue:&apos;areaCode&apos;,value:dq&quot;&gt;&lt;/select&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=function()&#123;</span><br><span class="line">self.cs=ko.observable(&quot;&quot;);</span><br><span class="line">self.dq=ko.observable(&quot;&quot;);</span><br><span class="line">self.cityWrap=ko.observableArray([</span><br><span class="line">&#123;name:&apos;北京&apos;,code:1001&#125;,</span><br><span class="line">&#123;name:&quot;上海&quot;,code:1002&#125;</span><br><span class="line">]);</span><br><span class="line">self.area=ko.observableArray([</span><br><span class="line">&#123;name:&apos;天安门&apos;,areaCode:100010,cityCode:1001&#125;,</span><br><span class="line">&#123;name:&apos;天坛&apos;,areaCode:100011,cityCode:1001&#125;,</span><br><span class="line">&#123;name:&apos;圆明园&apos;,areaCode:100012,cityCode:1001&#125;,</span><br><span class="line">&#123;name:&apos;上海门&apos;,areaCode:100013,cityCode:1002&#125;,</span><br><span class="line">&#123;name:&apos;上海侨&apos;,areaCode:100014,cityCode:1002&#125;</span><br><span class="line">]);</span><br><span class="line">self.currentCity=ko.computed(function()&#123;</span><br><span class="line">//这个是knock的数组过滤的方法</span><br><span class="line">return ko.utils.arrayFilter(self.area(),function(item)&#123;</span><br><span class="line">return item.cityCode==self.cs();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModel=new viewModel();</span><br><span class="line">ko.applyBindings(currentViewModel);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>applyBindings参数</strong><br>applyBindings有两个参数，applyBindings(currentViewModel,document.getElementById(“box”))<br>第一参数指视图对象，如上面的代码，第二参数是可选的，如果设置了第二个参数，比如box那么在元素设置里的id=box的元素下的后代元素可以使用视图模型里面定义的变量，在其他元素里面就不可以了。eg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;chenjiaobin&quot;&gt;</span><br><span class="line">   &lt;div data-bind=&quot;html:name&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;kevin&quot;&gt;</span><br><span class="line">   &lt;div data-bind=&quot;html:name&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=&#123;</span><br><span class="line">   username:ko.observable(&quot;陈焦滨&quot;)</span><br><span class="line">&#125;</span><br><span class="line">ko.applyBindings(viewModel,document.getElementById(&quot;chenjiaobin&quot;));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">最后在id=chenjiaobin元素下显示出来的是“陈焦滨”,在id=kevin下的元素先显示的则是&quot;&quot;</span><br></pre></td></tr></table></figure></p><p><strong>if和ifnot判断</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: displayMessage&quot; /&gt; Display message&lt;/label&gt;</span><br><span class="line">&lt;div data-bind=&quot;if: displayMessage&quot;&gt;Here is a message. Astonishing.&lt;/div&gt;//if应用</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: displayMessage&quot; /&gt; Display message&lt;/label&gt;</span><br><span class="line">&lt;div data-bind=&quot;ifnot: displayMessage&quot;&gt;Here is a message. Astonishing.&lt;/div&gt;//ifnot应用</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;ul data-bind=&quot;foreach: planets&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        Planet: &lt;b data-bind=&quot;text: name&quot;&gt; &lt;/b&gt;</span><br><span class="line">        &lt;div data-bind=&quot;if: capital&quot;&gt;</span><br><span class="line">            Capital: &lt;b data-bind=&quot;text: capital.cityName&quot;&gt; &lt;/b&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=&#123;</span><br><span class="line">   displayMessage:ko.observable(true),</span><br><span class="line">   planets: [</span><br><span class="line">            &#123; name: &apos;Mercury&apos;, capital: null &#125;, </span><br><span class="line">            &#123; name: &apos;Earth&apos;, capital: &#123; cityName: &apos;Barnsley&apos; &#125; &#125;        </span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">ko.applyBindings(viewModel);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>textInput的使用</strong><br>textInput与value的最大区别就是textInput它是实时更新的，而value需要离开焦点后才会生效<br>uniqueName主要是用来自动生成name值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; data-bind=&quot;textInput:kk，uniqueName：true&quot;&gt;//textInput的应用</span><br><span class="line">&lt;p data-bind=&quot;html:kk&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=&#123;</span><br><span class="line">   kk:ko.observable(&quot;打电话&quot;)</span><br><span class="line">&#125;</span><br><span class="line">ko.applyBindings(viewModel);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>hasFocus的使用</strong><br>当值为true时说明获得焦点，反之.<br>下面这个demo的效果是刚开始显示一串文字，点击文字后会显示输入框，离开焦点的时候输入框会消失<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p data-bind=&quot;visible:!edit(),text:something,click:changeFocus&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; data-bind=&quot;visible:edit,value:something,hasfocus:edit&quot;&gt;//hasfocus的使用</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=&#123;</span><br><span class="line">   something=ko.observable(&quot;来啊，互相伤害啊&quot;),</span><br><span class="line">edit=ko.observable(false),</span><br><span class="line">changeFocus=function()&#123;</span><br><span class="line">this.edit(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ko.applyBindings(viewModel);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>循环遍历的另一种做法</strong><br>下面这个遍历是knockout默认的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ko foreach:city --&gt;</span><br><span class="line">&lt;p data-bind=&quot;html:$data&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;!-- /ko --&gt;</span><br></pre></td></tr></table></figure></p><p><strong>复选框的checkedValue和checked</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ko foreach:city--&gt;</span><br><span class="line">&lt;input id=&quot;chk&quot; type=&quot;checkbox&quot; data-bind=&quot;checkedValue:$data,checked:$root.chkArr&quot;&gt;</span><br><span class="line">&lt;label for=&quot;chk&quot; data-bind=&quot;text:$data&quot;&gt;&lt;/label&gt;</span><br><span class="line">&lt;!--/ko--&gt;</span><br><span class="line">&lt;div data-bind=&quot;html:chkArr&quot;&gt;&lt;/div&gt;//点击选择复选框后选择的会在这个标签里面显示</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var viewModel=&#123;</span><br><span class="line">   chkArr:ko.observableArray(),</span><br><span class="line">city:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;]</span><br><span class="line">&#125;</span><br><span class="line">ko.applyBindings(viewModel);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>template属性的使用</strong><br>这个可以通过定义模板然后在指定的dom里面插进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-bind=&quot;template:&#123;name:&apos;mytemplate1&apos;,foreach:nobody&#125;&quot;&gt;&lt;/div&gt;//foreach的使用，循环</span><br><span class="line">&lt;div data-bind=&quot;template:&#123;name:&apos;mytemplate2&apos;,data:something&#125;&quot;&gt;&lt;/div&gt;//data的使用，一个对象数据，不用循环</span><br><span class="line">&lt;script type=&quot;text/html&quot; id=&quot;mytemplate1&quot;&gt;</span><br><span class="line">&lt;h1 data-bind=&quot;html:name&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h2 data-bind=&quot;html:age&quot;&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/html&quot; id=&quot;mytemplate2&quot;&gt;</span><br><span class="line">&lt;p data-bind=&quot;text:name&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var viewModel=function()&#123;</span><br><span class="line">var self=this;</span><br><span class="line">self.nobody=ko.observableArray([&#123;name:&quot;啥子呦&quot;,age:12&#125;,&#123;name:&quot;tony&quot;,age:24&#125;]);</span><br><span class="line">self.something=&#123;name:&quot;啥子呦&quot;,age:12&#125;</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModel=new viewModel();</span><br><span class="line">ko.applyBindings(currentViewModel);//激活视图模型</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>在这里还可以通过别名(as:’’)来设置获取值，这个主要是用在多重嵌套循环里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-bind=&quot;template:&#123;name:&apos;mytemplate1&apos;,foreach:nobody,as:&apos;chen&apos;&#125;&quot;&gt;&lt;/div&gt;//通过as设置别名</span><br><span class="line">&lt;script type=&quot;text/html&quot; id=&quot;mytemplate1&quot;&gt;</span><br><span class="line">&lt;h1 data-bind=&quot;html:name&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h2 data-bind=&quot;html:age&quot;&gt;&lt;/h2&gt;</span><br><span class="line">&lt;h3 data-bind=&quot;template:&#123;name:&apos;moreTemp&apos;,foreach:mm,as:&apos;jiaobin&apos;&#125;&quot;&gt;&lt;/h3&gt;//嵌套循环里面使用as命名第二个模板</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/html&quot; id=&quot;mytemplate2&quot;&gt;</span><br><span class="line">&lt;p data-bind=&quot;text:jiaobin&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var viewModel=function()&#123;</span><br><span class="line">var self=this;</span><br><span class="line">self.nobody=ko.observableArray([&#123;name:&quot;啥子呦&quot;,age:12,mm:[&apos;打篮球&apos;,&apos;游泳&apos;,&apos;打啥&apos;]&#125;,&#123;name:&quot;tony&quot;,age:24,mm:[&apos;乒乓球&apos;,&apos;羽毛球&apos;,&apos;弹吉他&apos;]&#125;]);</span><br><span class="line">&#125;</span><br><span class="line">var currentViewModel=new viewModel();</span><br><span class="line">ko.applyBindings(currentViewModel);//激活视图模型</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//这两个模板别名的作用是为了获取数据数据的时候出现混乱，比如，当第二个模板的数据里面也有name这个属性的时候,那么如果我们直接用`data-bind=&apos;text:name&apos;`的时候就可能输出的是第二个模板里面的name值，那如果我们设置了别名，我们就可以获取到parent的name值</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Knockout </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shape-outside元素实现iphone刘海效果</title>
      <link href="/2017/09/25/shapes%E5%85%83%E7%B4%A0/"/>
      <url>/2017/09/25/shapes%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>iphoneX的诞生，让很多人对它的刘海感到非常大的好奇心，那对于我们前端开发的人来说，关注点就是在他的布局上面了，怎么实现字体环绕他进行滚动？让文字不会被刘海挡住。<a id="more"></a>效果图如下：</p><p><img src="https://raw.githubusercontent.com/chenjiaobin/chenjiaobin.github.io/Source/themes/raytaylorism/source/css/images/shape.gif" alt="image"></p><p>CSS3里面针对这种特定形状环绕的效果已经支持很久了，CSS3 Shapes和CSS3 Regions都是可以实现的，接下来我们就用shapes来实现这一效果。<br>shape-outside属性要想生效，本身需要是浮动float元素。<br>本文demo效果实现使用的是shape-outside:polygon()，通过点坐标勾勒出和齐刘海形状相似的多边形形状，CSS代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.shape&#123;</span><br><span class="line">float: left;</span><br><span class="line">width: 30px;</span><br><span class="line">height: 340px;</span><br><span class="line">shape-outside: polygon(0 0, 0 150px, 16px 154px, 30px 166px, 30px 314px, 16px 326px, 0 330px, 0 0);</span><br><span class="line">    transition: shape-outside .15s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，后面没有设置BFC（块状格式化上下文）的列表元素就会自动环绕这个形状排列，也就是自动避开了齐刘海区域。<br>接着就是把刘海的图片覆盖在这个刘海区域上面，这样，刘海就做成了。<br>接着就是实现文字环绕刘海滚动的效果：<br>由于shape-outside所在的元素是浮动元素，因此，必定会跟着容器一起滚动，我们需要的效果是我们所绘制的这个刘海区域需要是固定的，那么我们就需要监听整个容器的滚动事件，将容器滚动的高度<code>scrollTop</code>加载每个刘海的纵坐标上面，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var box=document.getElementById(&quot;box&quot;); //这个是外层容器</span><br><span class="line">var shape=document.getElementById(&quot;shape&quot;); //这个是刘海容器</span><br><span class="line">shape.style.height=box.scrollHeight+&quot;px&quot;;  //这个的作用是将刘海的高度始终保持位置固定</span><br><span class="line">var fn=function()&#123;</span><br><span class="line">var scrollTop=box.scrollTop; //获取容器滚动的高度</span><br><span class="line">var shapeOutside = &apos;polygon(0 0, 0 &apos;+ (150 + scrollTop) +&apos;px, 16px &apos;+ (154 + scrollTop) +&apos;px, 30px &apos;+ (166 + scrollTop) +&apos;px, 30px &apos;+ (314 + scrollTop) +&apos;px, 16px &apos;+ (326 + scrollTop) +&apos;px, 0 &apos;+ (330 + scrollTop) +&apos;px, 0 0)&apos;; //将纵坐标加上scrollTop就实现了刘海固定的效果</span><br><span class="line">shape.style.webkitShapeOutside = shapeOutside;//兼容性</span><br><span class="line">shape.style.shapeOutside=shapeOutside;//将更新后的shapeOutside始终保持更新</span><br><span class="line">&#125;;</span><br><span class="line">  //滚动监听</span><br><span class="line">box.onscroll=function()&#123;</span><br><span class="line">fn(); </span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>CSS Shapes的兼容性为Chrome浏览器和Safari浏览器（包括iOS）都是支持的，也就意味着我们是可以在iPhone上使用的，完美。只是需要注意的是在iOS10.2及其之前的版本，CSS Shapes的使用还是需要加webkit私有前缀的，但据说iPhone X至少默认iOS 11，而刘海头交互效果就是针对iPhone X处理的，因此webkit私有前缀不加也没关系。</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;刘海&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 450px;</span><br><span class="line">margin: auto;</span><br><span class="line">overflow: auto;</span><br><span class="line">border:2px solid #000;</span><br><span class="line">&#125;</span><br><span class="line">.shape&#123;</span><br><span class="line">float: left;</span><br><span class="line">width: 30px;</span><br><span class="line">height: 340px;</span><br><span class="line">shape-outside: polygon(0 0, 0 150px, 16px 154px, 30px 166px, 30px 314px, 16px 326px, 0 330px, 0 0);</span><br><span class="line">    transition: shape-outside .15s;</span><br><span class="line">&#125;</span><br><span class="line">.icon&#123;</span><br><span class="line">width: 24px;</span><br><span class="line">height: 180px;</span><br><span class="line">background: url(http://www.zhangxinxu.com/study/201709/liu.png) no-repeat left center;</span><br><span class="line">position: absolute;</span><br><span class="line">margin-top: 150px;</span><br><span class="line">&#125;</span><br><span class="line">.content ul&#123;</span><br><span class="line">list-style: none;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.content li&#123;</span><br><span class="line">border-bottom: 1px solid #eee;</span><br><span class="line">padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;</span><br><span class="line">&lt;span class=&quot;shape&quot; id=&quot;shape&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;box1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var box=document.getElementById(&quot;box&quot;);</span><br><span class="line">var shape=document.getElementById(&quot;shape&quot;);</span><br><span class="line">shape.style.height=box.scrollHeight+&quot;px&quot;;</span><br><span class="line">var fn=function()&#123;</span><br><span class="line">var scrollTop=box.scrollTop;</span><br><span class="line">var shapeOutside = &apos;polygon(0 0, 0 &apos;+ (150 + scrollTop) +&apos;px, 16px &apos;+ (154 + scrollTop) +&apos;px, 30px &apos;+ (166 + scrollTop) +&apos;px, 30px &apos;+ (314 + scrollTop) +&apos;px, 16px &apos;+ (326 + scrollTop) +&apos;px, 0 &apos;+ (330 + scrollTop) +&apos;px, 0 0)&apos;;</span><br><span class="line">shape.style.webkitShapeOutside = shapeOutside;</span><br><span class="line">shape.style.shapeOutside=shapeOutside;</span><br><span class="line">&#125;;</span><br><span class="line">box.onscroll=function()&#123;</span><br><span class="line">fn();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这样就实现了文字环绕刘海的效果</p><p>参考网站：<a href="http://www.zhangxinxu.com/wordpress/2017/09/css-shapes-outside-iphone-x-head/" target="_blank" rel="noopener">地址1</a>|<a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226995&amp;idx=1&amp;sn=502119ff834717266d738fcbda8f6af7&amp;chksm=bd495af78a3ed3e127c9a186afe3bf9587a8c4b1dc4c1f11a936f31280ea5771c0d8cd21a949&amp;scene=0#rd" target="_blank" rel="noopener">地址2</a><br>作 者：陈焦滨&amp;kevin</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shape-outside </tag>
            
            <tag> polygon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议族</title>
      <link href="/2017/09/13/%E5%8D%8F%E8%AE%AE/"/>
      <url>/2017/09/13/%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>TCP/IP指的是网络通信协议，由网络层的IP协议和传输层的TCP协议组成。简单的说就是，他就是来解决电脑之间的通信的语言障碍，彼此有共同的语言进行交互。<a id="more"></a><br><strong>注</strong>：TCP协议不是一个协议，是一个协议族的统称，包括TCP协议、IP协议、IMCP协议、HTTP协议、FTP协议、POP3协议</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。意思就是限制每一次连接只处理一个请求，服务器处理完客户的请求后，并收到客户的<br>应答后，即断开连接，节省传输时间，http1.1实现了持续连接的功能。IP 负责将每个包路由至它的目的地。</li><li>TCP 用于应用程序之间的通信，UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。<br>TCP/IP 意味着 TCP 和 IP 在一起协同工作。<br>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。<br>IP 负责计算机之间的通信。<br>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。<br>IP 负责将包发送至接受者<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3>所谓三次握手就是TCP的连接，指建立一个TCP连接需要客户端和服务器端总共发起3个包以确认连接建立，在socket编程中，这一过程由客户端执行connect来触发<br>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li></ul><p>简单来说，就是</p><ol><li>建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</li><li>服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。<h3 id="SYN攻击："><a href="#SYN攻击：" class="headerlink" title="SYN攻击："></a>SYN攻击：</h3>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，<br>当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，<br>并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而<br>被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则<br>可以断定遭到SYN攻击了<h3 id="TCP四次握手"><a href="#TCP四次握手" class="headerlink" title="TCP四次握手"></a>TCP四次握手</h3>TCP四次握手即终止TCP连接，指断开TCP连接需要客户端和服务器端总共发送4个包来确认连接的断开，在socket编程中，这一过程由客户端或服务端任一方执行close来触发<br>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。<br>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3></li></ol><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，<br>仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送<br>FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p><h3 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h3><ul><li>无连接：意思就是限制每一次连接只处理一个请求，服务器处理完客户的请求后，并收到客户的应答后，即断开连接，节省传输时间，http1.1实现了持续连接的功能</li><li>无状态：指协议对于事务没有记忆能力，在次请求同样的资源必须重新访问服务器</li><li>URL是特定类型的uri:<br>URL组成，协议+资源主机IP地址+主机资源的具体地址<br>URI组成，访问资源的命名机制+存放资源的主机名+资源自身的名称<br>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。</li><li>一个http请求包括：请求行、请求头、空格、请求主体<br>  响应则包括：状态行、消息报头、空行、响应正文<br><strong> 客户端到服务器端的访问流程 </strong><br>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<h3 id="HTTP状态行"><a href="#HTTP状态行" class="headerlink" title="HTTP状态行"></a>HTTP状态行</h3>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：<br>200 OK      //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><p>参考文章:<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">地址1</a>|<a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="noopener">地址2</a><br>作者:陈焦滨#kevin</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display为table的应用</title>
      <link href="/2017/09/11/diplay-table/"/>
      <url>/2017/09/11/diplay-table/</url>
      
        <content type="html"><![CDATA[<p><code>display:table</code>和<code>display:table-cell</code>属性指让标签元素以表格和表格单元格的形式呈现，类似于table和td标签。目前IE8+以及其他现代浏览器都是支持此属性的，<br>但是IE6/7就不行了，需要写对应的hack来解决兼容性的问题<a id="more"></a></p><h3 id="display-table和table标签的比较"><a href="#display-table和table标签的比较" class="headerlink" title="display:table和table标签的比较"></a>display:table和table标签的比较</h3><table><thead><tr><th>display属性</th><th>table标签</th></tr></thead><tbody><tr><td>display:table</td><td>table</td></tr><tr><td>table-row</td><td>tr</td></tr><tr><td>table-cell</td><td>td</td></tr><tr><td>table-header-group</td><td>thead</td></tr><tr><td>table-footer-group</td><td>tfoot</td></tr><tr><td>table-row-group</td><td>tbody</td></tr><tr><td>table-column</td><td>col</td></tr><tr><td>table-caption</td><td>caption</td></tr></tbody></table><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们都知道，单元格有一些比较特别的属性，例如元素的<em>垂直居中对齐</em>，<em>关联伸缩</em>等，所以<code>display:table-cell</code>还是有不少潜在的使用价值的，虽说IE6/7不支持此属性，但是幸运的是，IE6/7一些乱糟糟的属性与渲染，我们可以其他方法实现同样或是类似的效果。<br>与其他一些display属性类似，table-cell同样会被其他一些CSS属性破坏，例如<strong>float, position:absolute</strong>，所以，在使用display:table-cell与<em>float:left</em>或是<em>position:absolute</em>属性尽量不用同用。设置了display:table-cell的元素对<strong>宽度高度敏感</strong>，对<strong>margin值无反应，响应padding属性</strong>，基本上就是活脱脱的一个td标签元素了。</p><h3 id="实现两栏适应布局"><a href="#实现两栏适应布局" class="headerlink" title="实现两栏适应布局"></a>实现两栏适应布局</h3><p>场景：左边一张图片，右边一行或多行文字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.HTML</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;#&quot; class=&quot;pic&quot;&gt;&lt;img src=&quot;#&quot;/&gt;&lt;/a&gt;</span><br><span class="line">  &lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">2.CSS</span><br><span class="line">.pic&#123;float:left&#125;</span><br><span class="line">.text&#123;display:table-row;*display:inline-block&#125;   //inline-block是为了解决ie8以下浏览器不兼容的问题</span><br></pre></td></tr></table></figure></p><h3 id="实现等高布局"><a href="#实现等高布局" class="headerlink" title="实现等高布局"></a>实现等高布局</h3><p>table表格中的单元格最大的特点之一就是同一行列表元素都等高。所以，很多时候，我们需要等高布局的时候，就可以借助<code>display:table-cell</code>属性。说到table-cell的布局，不得不说一下“匿名表格元素创建规则”：</p><blockquote><p>匿名表格元素创建规则:比如在一个子元素上设置<code>display:table-cell</code>，没有在父元素上设置<code>display:table-row</code>，那么浏览器会默认创建出一个行，也就是相当于帮你加上了display:table-row</p></blockquote><p>场景：实现三列等高布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.HTML</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">2.CSS</span><br><span class="line">.box&#123;display:table-row&#125;</span><br><span class="line">.cell&#123;display:table-cell;width:30%;margin-bottom:-100px;  *padding-bottom:110px; *float:left&#125; //加星号的是解决兼容性问题</span><br></pre></td></tr></table></figure></p><p>对于不支持display:table-cell属性的IE6/7浏览器，又当如何解决呢？<br>我们可以使用<strong>补差等高法</strong>，就是一个一个很大的<code>margin-bottom</code>负值配上一个同样大小的<code>padding-bottom</code>值</p><h3 id="大小不固定的图片和多行文字的垂直水平居中"><a href="#大小不固定的图片和多行文字的垂直水平居中" class="headerlink" title="大小不固定的图片和多行文字的垂直水平居中"></a>大小不固定的图片和多行文字的垂直水平居中</h3><p>单行文字居中可以通过<code>line-height</code>来实现<br>如果是多行文字垂直居中的话就需要用到<code>table-cell</code>了<br><strong>实现多行文字垂直居中</strong><br>场景：多行文字垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.HTML</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;text&quot;&gt;这里是多行文字内容&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">2.CSS</span><br><span class="line">.box&#123;diplay:table-cell;width:300px;height:500px;vertical-align:middle&#125;</span><br><span class="line">.text&#123;display:inline-block;vertical-align:middle&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现图片垂直居中</strong><br>场景：实现宽高不等的图片垂直居中排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.HTML</span><br><span class="line">&lt;ul class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;#&quot; /&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">2.CSS</span><br><span class="line">.box li&#123;float:left; margin-right:13px;&#125;</span><br><span class="line">.box li div&#123;display:table-cell; width:144px; height:144px; border:1px solid #beceeb; font-size:118px; text-align:center; vertical-align:middle;&#125;</span><br><span class="line">.box li div img&#123;vertical-align:middle;&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://www.zhangxinxu.com/wordpress/2010/10/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8Ddisplaytable-cell%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">参考文章</a></p><p>作者：陈焦滨#kevin</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> display </tag>
            
            <tag> table </tag>
            
            <tag> cell </tag>
            
            <tag> vertical-align </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS和tomcat公用80端口</title>
      <link href="/2017/09/11/IIS%E5%92%8CTomcat%E5%85%AC%E7%94%A880%E7%AB%AF%E5%8F%A3/"/>
      <url>/2017/09/11/IIS%E5%92%8CTomcat%E5%85%AC%E7%94%A880%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>很多时候，我们需要在一台服务器上部署多个网站并解析域名，但是域名访问默认是80端口，所以就需要解决一台服务器公用80端口的问题，下面我就向大家介绍一下配置过程<a id="more"></a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在IIS使用isapi_redirct转发给tomcat处理</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>windows 7,  iis7,  apache-tomcat-7.0.53</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.正确安装IIS<br>2.正确安装tomcat<br>3.下载isapi_redirct<br>下载地址：<a href="http://www.apache.org/dist/tomcat/tomcat-connectors/jk/binaries/windows/" target="_blank" rel="noopener">http://www.apache.org/dist/tomcat/tomcat-connectors/jk/binaries/windows/</a><br>特别注意，32位及64位系统使用对应的dll，否则会出现类似  调用GetFilterVersion失败 这样的异常<br>32位使用：tomcat-connectors-1.2.40-windows-i386-iis.zip<br>64位使用：tomcat-connectors-1.2.40-windows-x86_64-iis.zip<br>解压得到isapi_redirec的dll,将其重命名为：isapi_redirect.dll</p><h3 id="配置isapi-redirct"><a href="#配置isapi-redirct" class="headerlink" title="配置isapi_redirct"></a>配置isapi_redirct</h3><p>1.在Tomcat的安装文件夹【tomcat_home】下面新建文件夹jakarta，将isapi_redirect.dll 文件拷贝到里面<br>2.将isapi_redirect.dll文件拷贝到 【tomcat_home】/conf/ 文件夹下面<br>3.在【tomcat_home】/conf/ 文件夹下面(isapi_redirect.dll文件在里面)， 新建立一个与dll文件名相同，扩展名为properties的配置文件，即：isapi_redirect.properties，isapi_redirector.dll初始化时，默认会在自己所在的目录寻找同名的配置文件，如果没有再到注册表中读取配置信息.<br>isapi_redirect.properties的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension_uri=/jakarta/isapi_redirect.dll  </span><br><span class="line">log_file=D:/sw/tomcat7/logs/isapi_redirect.log  //这个是你自己tomcat的logs路径</span><br><span class="line">log_level=debug  </span><br><span class="line">worker_file=D:/sw/tomcat7/conf/workers.properties    //重新修改成你自己的路径</span><br><span class="line">worker_mount_file=D:/sw/tomcat7/conf/uriworkermap.properties  //重新修改成你自己的路径</span><br></pre></td></tr></table></figure></p><p>特别特别特别注意<br>isapi_redirect.properites的文件需要注意编码问题，在本次测试中我使用ansi编码才行，之前使用utf-8编码存储的时候，发生调用 GetFilterVersion 失败<br>4.在【tomcat_home】/conf/ 文件夹下面新建workers.properties文件，workers.properties内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">workers.tomcat_home=D:\sw\tomcat7\       //自己tomcat的路径</span><br><span class="line">workers.java_home=C:\Program Files\java\jdk.1.7.0_67   //你的jdk的路径</span><br><span class="line">ps=/  </span><br><span class="line">  </span><br><span class="line">#testiistom、examples为访问Tomcat服务器的一个标签,   </span><br><span class="line">#对应【tomcat_home】/webapps/文件夹下面的testiistom和examples文件夹，可以设置多个,用逗号隔开  </span><br><span class="line">worker.list=testiistom,examples  </span><br><span class="line">  </span><br><span class="line">worker.testiistom.type=ajp13  </span><br><span class="line">worker.testiistom.host=localhost  </span><br><span class="line">worker.testiistom.port=8009  </span><br><span class="line">worker.testiistom.lbfactor=1  </span><br><span class="line"></span><br><span class="line">worker.examples.type=ajp13  </span><br><span class="line">worker.examples.host=localhost  </span><br><span class="line">worker.examples.port=8009  </span><br><span class="line">worker.examples.lbfactor=1</span><br></pre></td></tr></table></figure></p><p>5.在【tomcat_home】/conf/ 文件夹下面新建uriworkermap.properties文件，uriworkermap.properties内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/testiistom/*=testiistom  </span><br><span class="line">/examples/*=examples</span><br></pre></td></tr></table></figure></p><p>注意：如果这样配置在最后输入域名访问到的是IIS页面的话，就重新配置成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*=testiistom  #必须要</span><br><span class="line">/system/=testiistom #访问system目录时转到Tomcat服务器处理（可有可无）</span><br><span class="line">/system/*.jsp=testiistom #system下.jsp文件转到Tomcat服务器处理（可有可无）</span><br><span class="line">/system/*=testiistom  #system下所有文件转到Tomcat服务器处理（可有可无）</span><br></pre></td></tr></table></figure></p><p>意思是去这个域名下面的所有文件转发给tomcat处理<br>说明：等号左边是路径规则，符合此规则的就通过Connector转发给tomcat。比如说在浏览器上访问   <a href="http://localhost/examples/，符合" target="_blank" rel="noopener">http://localhost/examples/，符合</a>  /example/*的规则，那么它就会转发给Tomcat对应的worker，转发目标worker名称为examples<br>等号右边即是workers.properties文件定义的worker</p><h3 id="配置IIS"><a href="#配置IIS" class="headerlink" title="配置IIS"></a>配置IIS</h3><p>因为公用80端口的这个方法是通过iis来转发给tomcat的，所以需要配置IIS<br>1.打开IIS，点击电脑节点，即最顶端那个节点<br>2.在中间区域框中找到【ISAPI和CGI限制】，双击它<br>3.双击【ISAPI和CGI限制】后，在右边框点击【添加】<br>      ISAPI或CGI路径(I)：选择【tomcat_home】\conf\isapi_redirect.dll<br>      描述：jakarta<br>      允许执行扩展路径(A)：要勾选<br>4.打开IIS，点击网站下面的【Default Web Site】节点<br>5.中间区域框找到【ISAPI筛选器】，双击它<br>6.双击【ISAPI筛选器】后，在右边框点击【添加】<br>     筛选器命名(F)：jakarta<br>     可执行文件(E)：选择【tomcat_home】\conf\isapi_redirect.dll<br>7.打开IIS，点击网站下面的【Default Web Site】节点<br>8.在中间区域框找到【处理程序映射】，双击它<br>9.双击【处理程序映射】后，在右边框点击【添加脚本映射…】<br>      请求路径：  *.jsp<br>      可执行文件(E)：选择【tomcat_home】\conf\isapi_redirect.dll<br>      名称：JSP<br>10.打开IIS，右键点击网站下面的【Default Web Site】-》添加虚拟目录<br>      名称：jakarta<br>      物理路径：【tomcat_home】\conf<br>      说明：在你需要整合Tomcat的网站（例如Default Web Site）下面，都要建立jakarta虚拟目录，并指向【tomcat_home】\conf，这个虚拟目录的名称必须与  五：配置isapi_redirec第二步 中配置的extension_uri的名称相同<br>11.打开IIS，点击网站下面的【Default Web Site】节点下面的  jakarta 虚拟目录节点<br>   在中间区域框找到【处理程序映射】，双击它，然后在右边框找到【编辑功能权限】，将所有的权限都勾选</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1.重新启动IIS和tomcat<br>2.访问你的域名，正常的话是可以访问，那就成功了，如果显示的页面是IIS页面，那就按我上面的那一个【配置isapi_redirect的第五步重新配置一下】重新配置<br>3.如果还是访问不到，那就域名+你的项目名，访问正常的话就OK了，那就去tomcat配置一下你的context内容</p><p><a href="http://blog.csdn.net/baijinwen/article/details/50562996" target="_blank" rel="noopener">参考文章1</a>|<a href="http://www.jb51.net/article/109723.htm" target="_blank" rel="noopener">参考文章2</a></p><p>作者：陈焦滨#kevin</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IIS </tag>
            
            <tag> Tomcat </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端设备像素比</title>
      <link href="/2017/09/08/dpr%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94/"/>
      <url>/2017/09/08/dpr%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。<a id="more"></a></p><h4 id="viewport概念"><a href="#viewport概念" class="headerlink" title="viewport概念"></a>viewport概念</h4><p>通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</p><h4 id="css中的1px并不等于设备的1px"><a href="#css中的1px并不等于设备的1px" class="headerlink" title="css中的1px并不等于设备的1px"></a>css中的1px并不等于设备的1px</h4><p>在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><p> 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p> 1.CSS像素（css pixel）:适用于web变成，指的是我们在样式代码中使用的逻辑像素，是个抽象的概念，实际并不存在<br> 2.设备独立像素（device independent pixel）:与设备无关的逻辑像素，指的是能通过程序控制的虚拟像素，是一个总体的概念，包括了css<br> 3.设备像素（device pixel）：物理像素，设备能控制的最小单位，我们常说的1920×1080像素分辨率就是用的设备像素单位</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p> PC端 —— 1个设备独立像素 = 1个设备像素 （在100%，未缩放的情况下，如果缩放到200%可以说1个设备独立像素 = 2个设备像素）<br> 移动端 —— 根据设备不同有很大的差异，根据 ppi 不同我们可以得到不同的换算关系，标准屏幕（160ppi）下 1个设备独立像素 = 1个设备像素</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>ppi （pixel per inch）：表示每英寸所包含的像素点数目，数值越高，说明屏幕能以更高密度显示图像（注：ppi在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（例如苹果公司的Retina显示屏））</p><h3 id="DPR"><a href="#DPR" class="headerlink" title="DPR"></a>DPR</h3><p>dpr（device pixel ratio）：设备像素比，设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系，在JS中可以通过 window.devicePixelRatio 获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素；</span><br><span class="line">当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素；</span><br><span class="line">当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素;</span><br></pre></td></tr></table></figure></p><p>所以如果我们要在非标准屏幕上以同样大小显示同一张图片时，就需要缩放图片大小<br>为什么是这样呢？就比如我们之前在CSS中设置图片大小为100px，要在dpr为<code>2:1</code>（即在一个方向上2个设备像素长度代表1个CSS像素长度）的Retia屏幕上同比例显示，就需要先放大这个图片到2被大小，即200px，这样我们在设备上对于图片的直观感受才是和标准屏幕相同。</p><p>我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。<br>这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？<br>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。</p><p>参考网站<a href="http://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">地址1</a> <a href="http://www.cnblogs.com/jiangzilong/p/6700023.html" target="_blank" rel="noopener">地址2</a><br>作者：陈焦滨</p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPR </tag>
            
            <tag> px </tag>
            
            <tag> ppi </tag>
            
            <tag> dpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This</title>
      <link href="/2017/09/04/This%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/09/04/This%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>日常开发中，我们经常用到this。例如用Jquery绑定事件时，this指向触发事件的DOM元素；编写Vue、React组件时，this指向组件本身。对于新手来说，常会用一种意会的感觉去判断this的指向。以至于当遇到复杂的函数调用时，就分不清this的真正指向。<br><a id="more"></a><br>本文将通过两道题去慢慢分析this的指向问题，并涉及到函数作用域与对象相关的点。最终给大家带来真正的理论分析，而不是简简单单的一句话概括。</p><p>相信若是对this稍有研究的人，都会搜到这句话：this总是指向调用该函数的对象。</p><p>然而箭头函数并不是如此，于是大家就会遇到如下各式说法：</p><ul><li><p>箭头函数的this指向外层函数作用域中的this。</p></li><li><p>箭头函数的this是定义函数时所在上下文中的this。</p></li><li><p>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p><h3 id="箭头函数实际表示"><a href="#箭头函数实际表示" class="headerlink" title="箭头函数实际表示"></a>箭头函数实际表示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var test = () =&gt; &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">//形式上等价于</span><br><span class="line">var test = function()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">//实质上等价于</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    var test = function()&#123;</span><br><span class="line">        console.log(that.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log( this.a );</span><br><span class="line">    &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); // 2</span><br><span class="line">//相当于</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var that = this; </span><br><span class="line">    setTimeout( function()&#123;</span><br><span class="line">        console.log( that.a );</span><br><span class="line">    &#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;chenjiaobin&quot;;</span><br><span class="line">var obj=&#123;</span><br><span class="line">    name:&apos;hh&apos;,</span><br><span class="line">    test:()=&gt;console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//相当于</span><br><span class="line">var name=&quot;chenjiaobin&quot;;</span><br><span class="line">var that=this;</span><br><span class="line">var obj=&#123;</span><br><span class="line">    name:&apos;hh&apos;,</span><br><span class="line">    test:function()&#123;</span><br><span class="line">        console.log(that.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.test()//chenjiaobin;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>箭头函数本身是没有this的，它的this是依靠外层函数的this决定的，如果没有外层函数就直接指向window<br>各式各样的说法都有，乍看下感觉说的差不多。废话不多说，凭着你之前的理解，来先做一套题吧（非严格模式下）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Question 1</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var person1 = &#123;</span><br><span class="line">  name: &apos;person1&apos;,</span><br><span class="line">  show1: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  show2: () =&gt; console.log(this.name),</span><br><span class="line">  show3: function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  show4: function () &#123;</span><br><span class="line">    return () =&gt; console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123; name: &apos;person2&apos; &#125;</span><br><span class="line"></span><br><span class="line">person1.show1()</span><br><span class="line">person1.show1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.show2()</span><br><span class="line">person1.show2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.show3()()</span><br><span class="line">person1.show3().call(person2)</span><br><span class="line">person1.show3.call(person2)()</span><br><span class="line"></span><br><span class="line">person1.show4()()</span><br><span class="line">person1.show4().call(person2)</span><br><span class="line">person1.show4.call(person2)()</span><br></pre></td></tr></table></figure></p><p>代码解读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//上面的show2属性代码相当于</span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line">var that=this;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">  //show2: () =&gt; console.log(this.name);这里因为没有外层函数所以this指向的是window的this，所以在全局里面定义了个that</span><br><span class="line">  show2:function()&#123;</span><br><span class="line">    console.log(that.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//上面的show4属性代码相当于</span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">  // show4: function () &#123;//这里有外层函数，就是这个function，所以在箭头函数的this指向的就是这个function的this值</span><br><span class="line">  //  return () =&gt; console.log(this.name);</span><br><span class="line">  // &#125;</span><br><span class="line">  show4:function()&#123;</span><br><span class="line">    var that=this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是，有两个对象person1，person2，然后花式调用person1中的四个show方法，预测真正的输出。<br>你可以先把自己预测的答案按顺序记在本子上，然后再往下拉看正确答案。<br>正确答案选下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person1.show1() // person1</span><br><span class="line">person1.show1.call(person2) // person2</span><br><span class="line"></span><br><span class="line">person1.show2() // window</span><br><span class="line">person1.show2.call(person2) // window</span><br><span class="line"></span><br><span class="line">person1.show3()() // window</span><br><span class="line">person1.show3().call(person2) // person2</span><br><span class="line">person1.show3.call(person2)() // window</span><br><span class="line"></span><br><span class="line">person1.show4()() // person1</span><br><span class="line">person1.show4().call(person2) // person1</span><br><span class="line">person1.show4.call(person2)() // person2</span><br></pre></td></tr></table></figure></p><p>对比下你刚刚记下的答案，是否有不一样呢？让我们尝试来最开始那些理论来分析下。</p><p>person1.show1()与person1.show1.call(person2)好理解，验证了谁调用此方法，this就是指向谁。</p><p>person1.show2()与person1.show2.call(person2)的结果用上面的定义解释，就开始让人不理解了。</p><p>它的执行结果说明this指向的是window。那就不是所谓的定义时所在的对象。<br>如果说是外层函数作用域中的this，实际上并没有外层函数了，外层就是全局环境了，这个说法也不严谨。<br>只有定义函数时所在上下文中的this这句话算能描述现在这个情况。<br>person1.show3是一个高阶函数，它返回了一个函数，分步走的话，应该是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var func = person3.show()</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure></p><p>从而导致最终调用函数的执行环境是window，但并不是window对象调用了它。所以说，this总是指向调用该函数的对象，这句话还得补充一句：在全局函数中，this等于window。</p><p>person1.show3().call(person2) 与 person1.show3.call(person2)() 也好理解了。前者是通过person2调用了最终的打印方法。后者是先通过person2调用了person1的高阶函数，然后再在全局环境中执行了该打印方法。</p><p>person1.show4()()，person1.show4().call(person2)都是打印person1。这好像又印证了那句：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。因为即使我用过person2去调用这个箭头函数，它指向的还是person1。</p><p>然而person1.show4.call(person2)()的结果又是person2。this值又发生改变，看来上述那句描述又走不通了。一步步来分析，先通过person2执行了show4方法，此时show4第一层函数的this指向的是person2。所以箭头函数输出了person2的name。也就是说，箭头函数的this指向的是谁调用箭头函数的外层function，箭头函数的this就是指向该对象，如果箭头函数没有外层函数，则指向window。这样去理解show2方法，也解释的通。</p><p>这句话就对了么？在我们学习的过程中，我们总是想以总结规律的方法去总结结论，并且希望结论越简单越容易描述就越好。实际上可能会错失真理。</p><p>下面我们再做另外一个相似的题目，通过构造函数来创建一个对象，并执行相同的4个show 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Question 2</span><br><span class="line"> */</span><br><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">function Person (name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.show1 = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  this.show2 = () =&gt; console.log(this.name)</span><br><span class="line">  this.show3 = function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.show4 = function () &#123;</span><br><span class="line">    return () =&gt; console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var personA = new Person(&apos;personA&apos;)</span><br><span class="line">var personB = new Person(&apos;personB&apos;)</span><br><span class="line"></span><br><span class="line">personA.show1()</span><br><span class="line">personA.show1.call(personB)</span><br><span class="line"></span><br><span class="line">personA.show2()</span><br><span class="line">personA.show2.call(personB)</span><br><span class="line"></span><br><span class="line">personA.show3()()</span><br><span class="line">personA.show3().call(personB)</span><br><span class="line">personA.show3.call(personB)()</span><br><span class="line"></span><br><span class="line">personA.show4()()</span><br><span class="line">personA.show4().call(personB)</span><br><span class="line">personA.show4.call(personB)()</span><br></pre></td></tr></table></figure></p><p>同样的，按照之前的理解，再次预计打印结果，把答案记下来，再往下拉看正确答案。</p><p>正确答案选下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">personA.show1() // personA</span><br><span class="line">personA.show1.call(personB) // personB</span><br><span class="line"></span><br><span class="line">personA.show2() // personA</span><br><span class="line">personA.show2.call(personB) // personA</span><br><span class="line"></span><br><span class="line">personA.show3()() // window</span><br><span class="line">personA.show3().call(personB) // personB</span><br><span class="line">personA.show3.call(personB)() // window</span><br><span class="line"></span><br><span class="line">personA.show4()() // personA</span><br><span class="line">personA.show4().call(personB) // personA</span><br><span class="line">personA.show4.call(personB)() // personB</span><br></pre></td></tr></table></figure></p><p>我们发现与之前字面量声明的相比，show2方法的输出产生了不一样的结果。为什么呢？虽然说构造方法Person是有自己的函数作用域。但是对于person1来说，它只是一个对象，在直观感受上，它跟第一道题中的person1应该是一模一样的。 JSON.stringify(new Person(‘person1’)) === JSON.stringify(person1)也证明了这一点。</p><p>说明构造函数创建对象与直接用字面量的形式去创建对象，它是不同的，构造函数创建对象，具体做了什么事呢？我引用红宝书中的一段话。<br>使用 new 操作符调用构造函数，实际上会经历一下4个步骤：<br>创建一个新对象；<br>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；<br>执行构造函数中的代码（为这个新对象添加属性）；<br>返回新对象。<br>所以与字面量创建对象相比，很大一个区别是它多了构造函数的作用域。</p><p>personA的函数的作用域链从构造函数产生的闭包开始，而person1的函数作用域仅是global，于是导致this指向的不同。我们发现，要想真正理解this，先得知道到底什么是作用域，什么是闭包。</p><p>有简单的说法称闭包就是能够读取其他函数内部变量的函数。然而这是一种闭包现象的描述，而不是它的本质与形成的原因。<br>…每个函数都有自己的执行环境（execution context，也叫执行上下文），每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p><p>…当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。当代码在环境中执行时，会创建一个作用域链，来保证对执行环境中的所有变量和函数的有序访问。函数执行之后，栈将环境弹出。</p><p>…函数内部定义的函数会将包含函数的活动对象添加到它的作用域链中。</p><p>具体来说，当我们 var func = personA.show3() 时，personA的show3函数的活动对象，会一直保存在func的作用域链中。只要不销毁func，那么show3函数的活动对象就会一直保存在内存中。（chrome的v8引擎对闭包的开销会有优化）</p><p>而构造函数同样也是闭包的机制，personA的show1方法，是构造函数的内部函数，因此执行了 this.show3 = function () { console.log(this.name) }时，已经把构造函数的活动对象推到了show3函数的作用域链中。</p><p>我们再回到this的指向问题。我们发现，单单是总结规律，或者用一句话概括，已经难以正确解释它到底指向谁了，我们得追本溯源。</p><p>红宝书中说道：</p><p>…this引用的是函数执行的环境对象（便于理解，贴上英文原版：It is a reference to the context object that the function is operating on）。 …每个函数被调用时都会自动获取两个特殊变量：this和arguments。内部在搜索这个两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。</p><p>我们看下MDN中箭头函数的概念：</p><p>一个箭头函数表达式的语法比一个函数表达式更短，并且不绑定自己的 this，arguments，super或 new.target。…箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。</p><p>也就是说，普通情况下，this指向调用函数时的对象。在全局执行时，则是全局对象。</p><p>箭头函数的this，因为没有自身的this，所以this只能根据作用域链往上层查找，直到找到一个绑定了this的函数作用域（即最靠近箭头函数的普通函数作用域，或者全局环境），并指向调用该普通函数的对象。</p><p>或者从现象来描述的话，即箭头函数的this指向声明函数时，最靠近箭头函数的普通函数的this。但这个this也会因为调用该普通函数时环境的不同而发生变化。导致这个现象的原因是这个普通函数会产生一个闭包，将它的变量对象保存在箭头函数的作用域中。</p><p>故而personA的show2方法因为构造函数闭包的关系，指向了构造函数作用域内的this。而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var func = personA.show4.call(personB)</span><br><span class="line"></span><br><span class="line">func() // print personB</span><br></pre></td></tr></table></figure></p><p>因为personB调用了personA的show4，使得返回函数func的作用域的this绑定为personB，进而调用func时，箭头函数通过作用域找到的第一个明确的this为personB。进而输出personB。</p><p>讲了这么多，可能还是有点绕。总之，想充分理解this的前提，必须得先明白js的执行环境、闭包、作用域、构造函数等基础知识。然后才能得出清晰的结论。</p><p>我们平常在学习过程中，难免会更倾向于根据经验去推导结论，或者直接去找一些通俗易懂的描述性语句。然而实际上可能并不是最正确的结果。如果想真正掌握它，我们就应该追本溯源的去研究它的内部机制。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://www.cnblogs.com/xiaohuochai/p/5737876.html" target="_blank" rel="noopener">文章1</a><br><a href="http://mp.weixin.qq.com/s/qoHAYft7gdr8h058E-zBJw" target="_blank" rel="noopener">文章2</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> 作用域 </tag>
            
            <tag> This </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Git+GitHub+Travis部署个人博客</title>
      <link href="/2017/08/29/HGGT/"/>
      <url>/2017/08/29/HGGT/</url>
      
        <content type="html"><![CDATA[<p>作为一个高端大气上档次的技术开发者来说，拥有属于自己的博客是非常有必要滴，有了技术博客我们可以干嘛？…… 听我细细道来,技术博客不仅可有装B，又能将自己学到的知识概括性的一字面形式写出来，即强化了自己的知识，当然也方便了他人，一箭双雕，两全其美，何乐而不为。<a id="more"></a><br>废话不多说，直接进主题吧！！！！<br>你现在说看到的这个博客就是我用一下技术来实现的<em>Hexo+Git+GitHub+Travis</em><br>开始你的博客搭建吧~~~</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.现在很多东西都是需要用到git和node.js的，所以先在你的电脑上安装git和node.js，这种简单的操作就自己百度脑补了哈！本哈就不介绍了！<br>2.注册一个GitHub账号</p><h3 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题<br>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh    #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure></p><p>如果提示：No such file or directory 说明你是第一次使用git，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa  #生成公钥和秘钥</span><br></pre></td></tr></table></figure></p><p>会要求你填写钥匙的名字，最好还是用它原本的那个<code>id_rsa</code>，要不后面可能会出现#### 大问题，本哈就在这里栽了跟头，然后就是输入密码，这个密码是你每次提交代码时需要输入的。生成这两个钥匙后将私钥放到.ssh文件夹里面去#### （切记切记切记），如果没有.ssh这个文件夹先不要急，先继续往下做，后面再把他们放到.ssh里面去，将公钥用文本编辑器打开复制全部内容，进入github，在setting–ssh and gpg key–new ssh key新建一个sshkey,将刚才复制的东西复制进去，名字自己随便取。</p><h3 id="测试是否连接成功"><a href="#测试是否连接成功" class="headerlink" title="测试是否连接成功"></a>测试是否连接成功</h3><p>如果看见Hi xxx,you,ve successfully，那么你成功了（一般执行完这一步前面没有.ssh文件夹的问题算是解决了，现在已经有这个文件夹了，赶紧把钥匙文件复制进去）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果失败了就执行以下命令进行查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -v git@github.com</span><br></pre></td></tr></table></figure></p><h3 id="配置github全局账户"><a href="#配置github全局账户" class="headerlink" title="配置github全局账户"></a>配置github全局账户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  --global user.name &quot;your account&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>到这一步配置算是告一段落了，休息一下吧。。。。。</p><p>接着就是创建你的博客了，来吧，继续</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://hexo.io/docs/setup.html" target="_blank" rel="noopener">Hexo</a>是一套基于node.js的静态博客框架。新建一个文件夹Blog,进入文件夹，右键有个<code>git bash here</code>（安装完git才有）,点击进入，执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo  #全局安装hexo</span><br></pre></td></tr></table></figure></p><p>接着初始化这个文件夹Blog，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init  #初始化</span><br></pre></td></tr></table></figure></p><p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。。默认有个模板是可以用的，如果不喜欢的话自己下载一个替换就行了。提供个<a href="https://hexo.io/themes/" target="_blank" rel="noopener">下载地址</a>给你吧!克隆出模板后放在theme文件夹里面，然后到根目录的_config.yml里面的theme换成你的主题名称就ok了，具体主题的一些配置要看主题的作者的介绍。<br>接着就是要生成静态文件了，也就是生成浏览器认识的代码格式html,执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成静态文件</span><br><span class="line">hexo s #启动服务，可以在本地通过localhost:4000来访问</span><br></pre></td></tr></table></figure></p><p>如果在浏览器预览不了就看一下端口时候被占用了</p><h3 id="将博客放到github"><a href="#将博客放到github" class="headerlink" title="将博客放到github"></a>将博客放到github</h3><p>修改根目录的_config.yml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h3 id="安装提交插件"><a href="#安装提交插件" class="headerlink" title="安装提交插件"></a>安装提交插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>好了，在你的github上面已经能看到你的东西了，也直接可以访问了</p><p>继续，还有活干呢！！已经快到达终点了哈</p><h3 id="配置Tracis"><a href="#配置Tracis" class="headerlink" title="配置Tracis"></a>配置Tracis</h3><p>其实这个也不用怎么配置那，不要被吓到，用GitHub账号登录，然后点击<code>sync acconunt</code>将你GitHub上面的仓库同步过来，然后点击你要部署的仓库，将前面的开关开起来，接着点击项目链接进入页面，在这个页面你会看到<code>more option</code>,选中里面的<code>setting</code>,将general里面的<code>Build only ...</code>开起来，其他默认。接着还有，将下面的<code>Environment Variables</code>设置变量，在这里先停一下，先到你根目录创建一个<code>.travis.yml</code>文件，这个文件非常重要，文件内容可以参考该<a href="https://troyyang.com/2017/06/24/Travis_Auto_Build_Deploy_Github_Projects/" target="_blank" rel="noopener">链接</a>修改你的账户和邮箱和创库<br>接着就右键项目，创建新分支，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch source  #名字自己随意,但是这个名字要跟.travis.yml里面的branch的名字一样</span><br></pre></td></tr></table></figure></p><p>然后在通过执行以下命令将分支提交到你的仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout source #切换分支</span><br><span class="line">git add  .</span><br><span class="line">git commit -m &apos;提交说明&apos;</span><br><span class="line">git pull</span><br><span class="line">git push origin source #提交分支</span><br></pre></td></tr></table></figure></p><p>接着继续回到travis，刚才那个<code>name</code>的值就是.travis.yml里面那个<code>git push --force --quiet &quot;https://${GitHub_TOKEN}@${GH_REF}&quot; master:master</code>里面的<code>GitHub_TOKEN</code>，后面的值就是你在前面复制到github上面的公钥的内容，复制一遍到这里来，点击<code>add</code>，就ok了</p><p>不出意外，你的博客已经建好了，是不是很嗨森！！！<br>如果命不好出现问题那只能自己慢慢调试了，这也能锻炼你调试代码和配置的能力！！<br>总之，加油吧！！</p><p>作者：陈焦滨&amp;kevin</p>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Travis </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
