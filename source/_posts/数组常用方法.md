---
title: 冒泡和去重
date: 2018-02-02 22:15:00
tags: 
- 冒泡排序
- 数组去重
categories:
- 前端
- JS
---
这里简单介绍介绍一下数组几个常常会被问到的数组处理的解决方法
### 数组排序
- 冒泡排序
```
function mp(arr){
  for(var i=0,len=arr.length;i<len;i++){
    for(var j=i+1;j<len;j++){
      if(arr[i]>arr[j]){
        var flag=arr[i];
        arr[i]=arr[j];
        arr[j]=flag;
      }
    }
    return arr;
  }
}
```
- 快速排序(二元法)
```
function ey(arr){
  if(arr.length==0){
    return [];
  }
  var midIndex=Math.floor((arr.length/2));
  var midVal=arr.splice(midIndex,1);
  var left=[];
  var right=[];
  for(var i=0,len=arr.length;i<len;i++){
    if(arr[i]<midVal){
      left.push(arr[i]);
    }else{
      right.push(arr[i]);
    }
  }
  return ey(left).concat(midVal,ey(right));
}
```
- sort方法
```
function so(a,b){
return a-b;
}
function px(arr,fn){
 return arr.sort(fn);
}
```
### 数组去重
- indexOf
```
function unique(arr){
  var newArr=[arr[0]];
  for(var i=0,len=arr.length;i<len;i++){
    if(newArr.indexOf(arr[i])==-1){
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```
- 循环判断
```
function unique(arr){
  var newArr=[];
  for(var i=0,len=arr.length;i<len;i++){
    var flag=false;
    for(var j=0;j<len;j++){
      if(arr[i]==arr[j]){
        flag=true;
      }
    }
    if(!flag){
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

### 二叉树
树是一种非线性数据存储结构，一般用来存储有层级关系的数据，比如文件系统的文件和有序列表，二叉树的特征是子节点不能超过2个
```
//这个是后面需要创建的每个节点的构造函数，每个节点有对应的数据
function Node(data,left,right){
  this.data=data;
  this.left=left;
  this.right=right;
  this.show=show;
}
//这个是给节点返回数据的
function show(){
  return this.data;
}
//这个是实例化树结构的操作函数
function BST(){
  this.root=null;
  this.insert=insert;//插入函数操作
  this.inOrder = inOrder;
  this.getMin = getMin;
  this.getMax = getMax;
  this.find = find;
  this.remove = remove;
}
//分装插入函数的逻辑
function insert(data){
  var n=new Node(data,null,null);//先实例化出一个子节点，还没有被插入
  if(this.root==null){
    this.root=n;
  }else{
    var current=this.root;
    var parent;
    while(current){
      parent=current;
      if(data<current.data){
        current=current.left;
        if(current==null){
          parent.left=n;
          break;
        }
      }else{
        current=current.right;
        if(current==null){
          parent.right=n;
          break;
        }
      }
    }
  }
}
//中序遍历
function midOrder(node){
  if(!(node==null)){
    midOrder(node.left);
    console.log(node.show());
    midOrder(node.right);
  }
}
//先序遍历
fucnction preOrder(node){
   if(!(node==null)){
    console.log(node.show());
    preOrder(node.left);
    preOrder(node.right);
  }
}
//后序遍历
function afterOrder(node){
  if(!(node==null)){
    afterOrder(node.left);
    afterOrder(node.right);
    console.log(node.show());
  }
}

//查询最小值
function getMin(){
  var current=this.root;
  while(!(current.left==null)){
    current=current.left;
  }
  return current.data;
}
// 二叉树上查找最大值
function getMax() {
    var current = this.root;
    while(!(current.right == null)) {
        current = current.right;
    }
    return current.data;
}
// 查找给定值
function find(data) {
    var current = this.root;
    while(current != null) {
        if(current.data == data) {
            return current;
        }else if(data < current.data) {
            current = current.left;
        }else {
            current = current.right;
        }
    }
    return null;
}
function remove(data) {
    root = removeNode(this.root,data);
}
function getSmallest(node) {
   if (node.left == null) {
      return node;
   }
   else {
      return getSmallest(node.left);
   }
}
function removeNode(node,data) {
    if(node == null) {
        return null;
    }
    if(data == node.data) {
        // 没有子节点的节点
        if(node.left == null && node.right == null) {
            return null;
        } 
        // 没有左子节点的节点
        if(node.left == null) {
            return node.right;
        }
        // 没有右子节点的节点
        if(node.right == null) {
            return node.left;
        }
        // 有2个子节点的节点
        var tempNode = getSmallest(node.right);
        node.data = tempNode.data;
        node.right = removeNode(node.right,tempNode.data);
        return node;
    }else if(data < node.data) {
        node.left = removeNode(node.left,data);
        return node;
    }else {
        node.right = removeNode(node.right,data);
        return node;
    }
}
//代码初始化
代码初始化如下：
var nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(22);
midOrder(nums.root);//3,16,22,23,37,49,45
preOrder(nums.root);//23,16,3,,22,45,37,99
after(nums.root);//3,22,16,37,99,45
var min = nums.getMin();
console.log(min);//3
var max = nums.getMax();
console.log(max);//99
var value = nums.find("45");
console.log(value);//
nums.remove(23);
```
> 参考文章：https://www.cnblogs.com/tugenhua0707/p/4361051.html
